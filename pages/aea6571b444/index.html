<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端常见技术面试 | YuKang&#39;s blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="web前端技术博客,简洁至上,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.a8571fce.css" as="style"><link rel="preload" href="/assets/js/app.da88fcfe.js" as="script"><link rel="preload" href="/assets/js/2.d6d313e5.js" as="script"><link rel="preload" href="/assets/js/71.5951b3f0.js" as="script"><link rel="prefetch" href="/assets/js/10.0fa021af.js"><link rel="prefetch" href="/assets/js/100.4be9c85b.js"><link rel="prefetch" href="/assets/js/101.d80aeb64.js"><link rel="prefetch" href="/assets/js/102.9f9c0dcc.js"><link rel="prefetch" href="/assets/js/103.2605578d.js"><link rel="prefetch" href="/assets/js/104.49af3597.js"><link rel="prefetch" href="/assets/js/105.76d5b455.js"><link rel="prefetch" href="/assets/js/106.423bef44.js"><link rel="prefetch" href="/assets/js/107.de97436a.js"><link rel="prefetch" href="/assets/js/108.6454a745.js"><link rel="prefetch" href="/assets/js/109.6205006c.js"><link rel="prefetch" href="/assets/js/11.f1c39825.js"><link rel="prefetch" href="/assets/js/110.4e1c9d62.js"><link rel="prefetch" href="/assets/js/111.ddde9d13.js"><link rel="prefetch" href="/assets/js/112.2f3686ee.js"><link rel="prefetch" href="/assets/js/113.c6babe3d.js"><link rel="prefetch" href="/assets/js/114.08761fce.js"><link rel="prefetch" href="/assets/js/115.0ea6efda.js"><link rel="prefetch" href="/assets/js/116.236686ee.js"><link rel="prefetch" href="/assets/js/117.fd76aee9.js"><link rel="prefetch" href="/assets/js/118.c563c9cd.js"><link rel="prefetch" href="/assets/js/119.00bc0d8f.js"><link rel="prefetch" href="/assets/js/12.30236b12.js"><link rel="prefetch" href="/assets/js/120.8c995544.js"><link rel="prefetch" href="/assets/js/121.99ba5552.js"><link rel="prefetch" href="/assets/js/122.02849397.js"><link rel="prefetch" href="/assets/js/123.df3ded3f.js"><link rel="prefetch" href="/assets/js/124.dd91e981.js"><link rel="prefetch" href="/assets/js/125.5cb944d6.js"><link rel="prefetch" href="/assets/js/126.1a007178.js"><link rel="prefetch" href="/assets/js/127.db6df40f.js"><link rel="prefetch" href="/assets/js/128.d79474c3.js"><link rel="prefetch" href="/assets/js/129.caf42d76.js"><link rel="prefetch" href="/assets/js/13.d235ed1c.js"><link rel="prefetch" href="/assets/js/130.7869607d.js"><link rel="prefetch" href="/assets/js/131.a24f8114.js"><link rel="prefetch" href="/assets/js/132.7daea2fc.js"><link rel="prefetch" href="/assets/js/133.7fdbafb7.js"><link rel="prefetch" href="/assets/js/134.ee072ff8.js"><link rel="prefetch" href="/assets/js/135.4765a627.js"><link rel="prefetch" href="/assets/js/136.b85b38cd.js"><link rel="prefetch" href="/assets/js/137.64f222b3.js"><link rel="prefetch" href="/assets/js/138.50a8eeec.js"><link rel="prefetch" href="/assets/js/139.489be3a0.js"><link rel="prefetch" href="/assets/js/14.31d9973e.js"><link rel="prefetch" href="/assets/js/140.e65d33c7.js"><link rel="prefetch" href="/assets/js/141.86c01397.js"><link rel="prefetch" href="/assets/js/142.9c7deac4.js"><link rel="prefetch" href="/assets/js/143.d55fd773.js"><link rel="prefetch" href="/assets/js/144.5dc2c72f.js"><link rel="prefetch" href="/assets/js/145.736f6e65.js"><link rel="prefetch" href="/assets/js/146.8dc4f251.js"><link rel="prefetch" href="/assets/js/147.6e897338.js"><link rel="prefetch" href="/assets/js/148.c2621b23.js"><link rel="prefetch" href="/assets/js/149.882e716c.js"><link rel="prefetch" href="/assets/js/15.832bdd64.js"><link rel="prefetch" href="/assets/js/150.1397a255.js"><link rel="prefetch" href="/assets/js/151.29f43ba4.js"><link rel="prefetch" href="/assets/js/152.70386413.js"><link rel="prefetch" href="/assets/js/153.d4e54008.js"><link rel="prefetch" href="/assets/js/154.58483438.js"><link rel="prefetch" href="/assets/js/155.c1d740e9.js"><link rel="prefetch" href="/assets/js/156.d96d56a2.js"><link rel="prefetch" href="/assets/js/157.cab23b21.js"><link rel="prefetch" href="/assets/js/158.7a6d194a.js"><link rel="prefetch" href="/assets/js/159.dd4bbdf5.js"><link rel="prefetch" href="/assets/js/16.3cefc80a.js"><link rel="prefetch" href="/assets/js/160.48e37847.js"><link rel="prefetch" href="/assets/js/161.ed16742b.js"><link rel="prefetch" href="/assets/js/162.c5e892e5.js"><link rel="prefetch" href="/assets/js/163.baa4506e.js"><link rel="prefetch" href="/assets/js/164.369985c5.js"><link rel="prefetch" href="/assets/js/165.a53e0010.js"><link rel="prefetch" href="/assets/js/166.693ab1d1.js"><link rel="prefetch" href="/assets/js/167.35d83b98.js"><link rel="prefetch" href="/assets/js/168.d388c022.js"><link rel="prefetch" href="/assets/js/169.37cd35da.js"><link rel="prefetch" href="/assets/js/17.e3ad30cf.js"><link rel="prefetch" href="/assets/js/170.f94b4a86.js"><link rel="prefetch" href="/assets/js/171.8410ba2c.js"><link rel="prefetch" href="/assets/js/172.161dc27f.js"><link rel="prefetch" href="/assets/js/173.dac614bb.js"><link rel="prefetch" href="/assets/js/174.0550ca1c.js"><link rel="prefetch" href="/assets/js/175.f6dd0b22.js"><link rel="prefetch" href="/assets/js/176.8066b681.js"><link rel="prefetch" href="/assets/js/177.b8d40d0f.js"><link rel="prefetch" href="/assets/js/178.18893da0.js"><link rel="prefetch" href="/assets/js/179.9b15d785.js"><link rel="prefetch" href="/assets/js/18.60457f10.js"><link rel="prefetch" href="/assets/js/180.2fab7da4.js"><link rel="prefetch" href="/assets/js/181.c5fb348c.js"><link rel="prefetch" href="/assets/js/182.997b6834.js"><link rel="prefetch" href="/assets/js/183.43e369c7.js"><link rel="prefetch" href="/assets/js/184.42cd4d36.js"><link rel="prefetch" href="/assets/js/185.c9f43e0f.js"><link rel="prefetch" href="/assets/js/186.5532e541.js"><link rel="prefetch" href="/assets/js/187.6921d607.js"><link rel="prefetch" href="/assets/js/188.3d6a905d.js"><link rel="prefetch" href="/assets/js/189.cd9e3266.js"><link rel="prefetch" href="/assets/js/19.7b004086.js"><link rel="prefetch" href="/assets/js/190.3c74f9c1.js"><link rel="prefetch" href="/assets/js/191.ec63e145.js"><link rel="prefetch" href="/assets/js/192.206df1ed.js"><link rel="prefetch" href="/assets/js/193.43ba4b30.js"><link rel="prefetch" href="/assets/js/194.77c35c2b.js"><link rel="prefetch" href="/assets/js/195.3cbd658d.js"><link rel="prefetch" href="/assets/js/196.651f9b19.js"><link rel="prefetch" href="/assets/js/197.cead71ff.js"><link rel="prefetch" href="/assets/js/198.708e561a.js"><link rel="prefetch" href="/assets/js/199.c1b39578.js"><link rel="prefetch" href="/assets/js/20.ca5d6e8a.js"><link rel="prefetch" href="/assets/js/200.ff79e0e2.js"><link rel="prefetch" href="/assets/js/201.db5688f3.js"><link rel="prefetch" href="/assets/js/202.b3a2eb5c.js"><link rel="prefetch" href="/assets/js/203.c8287fa7.js"><link rel="prefetch" href="/assets/js/204.d2d71a59.js"><link rel="prefetch" href="/assets/js/205.de2fa652.js"><link rel="prefetch" href="/assets/js/206.30166c26.js"><link rel="prefetch" href="/assets/js/207.9ed41a31.js"><link rel="prefetch" href="/assets/js/208.565efb01.js"><link rel="prefetch" href="/assets/js/209.54c0b830.js"><link rel="prefetch" href="/assets/js/21.234e994e.js"><link rel="prefetch" href="/assets/js/210.9e7b78e5.js"><link rel="prefetch" href="/assets/js/211.1b57ff82.js"><link rel="prefetch" href="/assets/js/212.81597f0d.js"><link rel="prefetch" href="/assets/js/213.ba2cd2fc.js"><link rel="prefetch" href="/assets/js/214.507c8087.js"><link rel="prefetch" href="/assets/js/215.b9d0df90.js"><link rel="prefetch" href="/assets/js/216.2fefa231.js"><link rel="prefetch" href="/assets/js/217.a4a3871e.js"><link rel="prefetch" href="/assets/js/218.ea1b9fd1.js"><link rel="prefetch" href="/assets/js/219.9b73b14a.js"><link rel="prefetch" href="/assets/js/22.70ef1838.js"><link rel="prefetch" href="/assets/js/220.38674318.js"><link rel="prefetch" href="/assets/js/23.eba298c9.js"><link rel="prefetch" href="/assets/js/24.63de8327.js"><link rel="prefetch" href="/assets/js/25.889c2727.js"><link rel="prefetch" href="/assets/js/26.5d504432.js"><link rel="prefetch" href="/assets/js/27.c7c2b45d.js"><link rel="prefetch" href="/assets/js/28.87606445.js"><link rel="prefetch" href="/assets/js/29.8213f3f9.js"><link rel="prefetch" href="/assets/js/3.27e16978.js"><link rel="prefetch" href="/assets/js/30.e7cdfd9d.js"><link rel="prefetch" href="/assets/js/31.f3c4da70.js"><link rel="prefetch" href="/assets/js/32.55e73512.js"><link rel="prefetch" href="/assets/js/33.6dc76f2a.js"><link rel="prefetch" href="/assets/js/34.64d6a62d.js"><link rel="prefetch" href="/assets/js/35.9e3cda25.js"><link rel="prefetch" href="/assets/js/36.67cfdc48.js"><link rel="prefetch" href="/assets/js/37.9d90a4b1.js"><link rel="prefetch" href="/assets/js/38.2b9966b9.js"><link rel="prefetch" href="/assets/js/39.10a64aa0.js"><link rel="prefetch" href="/assets/js/4.49886a35.js"><link rel="prefetch" href="/assets/js/40.de0b3f6e.js"><link rel="prefetch" href="/assets/js/41.2d573ff0.js"><link rel="prefetch" href="/assets/js/42.d1ca860f.js"><link rel="prefetch" href="/assets/js/43.e468c80f.js"><link rel="prefetch" href="/assets/js/44.698b1f5f.js"><link rel="prefetch" href="/assets/js/45.b24d19b5.js"><link rel="prefetch" href="/assets/js/46.79b1a1a4.js"><link rel="prefetch" href="/assets/js/47.34ae2867.js"><link rel="prefetch" href="/assets/js/48.d8bd1b3d.js"><link rel="prefetch" href="/assets/js/49.29fac802.js"><link rel="prefetch" href="/assets/js/5.1a665cf5.js"><link rel="prefetch" href="/assets/js/50.69ae7ce4.js"><link rel="prefetch" href="/assets/js/51.08c589f4.js"><link rel="prefetch" href="/assets/js/52.0d1b8599.js"><link rel="prefetch" href="/assets/js/53.c1a15e8c.js"><link rel="prefetch" href="/assets/js/54.36fcab6a.js"><link rel="prefetch" href="/assets/js/55.4d6dcf2d.js"><link rel="prefetch" href="/assets/js/56.a6ed5717.js"><link rel="prefetch" href="/assets/js/57.507544ae.js"><link rel="prefetch" href="/assets/js/58.7f8cc409.js"><link rel="prefetch" href="/assets/js/59.866f87dd.js"><link rel="prefetch" href="/assets/js/6.385dcd95.js"><link rel="prefetch" href="/assets/js/60.6979c8b5.js"><link rel="prefetch" href="/assets/js/61.4041dad4.js"><link rel="prefetch" href="/assets/js/62.bb1ecf45.js"><link rel="prefetch" href="/assets/js/63.cd465998.js"><link rel="prefetch" href="/assets/js/64.31ad9540.js"><link rel="prefetch" href="/assets/js/65.dc909e9e.js"><link rel="prefetch" href="/assets/js/66.91dc61aa.js"><link rel="prefetch" href="/assets/js/67.df3d44e3.js"><link rel="prefetch" href="/assets/js/68.af44fac6.js"><link rel="prefetch" href="/assets/js/69.117f2815.js"><link rel="prefetch" href="/assets/js/7.5d2b8781.js"><link rel="prefetch" href="/assets/js/70.497c599f.js"><link rel="prefetch" href="/assets/js/72.5d7731af.js"><link rel="prefetch" href="/assets/js/73.38f288e0.js"><link rel="prefetch" href="/assets/js/74.d39236a0.js"><link rel="prefetch" href="/assets/js/75.fc13e1a2.js"><link rel="prefetch" href="/assets/js/76.d995a290.js"><link rel="prefetch" href="/assets/js/77.eb084575.js"><link rel="prefetch" href="/assets/js/78.3cd5fb71.js"><link rel="prefetch" href="/assets/js/79.73ad47e9.js"><link rel="prefetch" href="/assets/js/8.1a691d30.js"><link rel="prefetch" href="/assets/js/80.80994a59.js"><link rel="prefetch" href="/assets/js/81.3896cc59.js"><link rel="prefetch" href="/assets/js/82.bf346748.js"><link rel="prefetch" href="/assets/js/83.60d0f019.js"><link rel="prefetch" href="/assets/js/84.66e7458f.js"><link rel="prefetch" href="/assets/js/85.8eaf34be.js"><link rel="prefetch" href="/assets/js/86.4b519767.js"><link rel="prefetch" href="/assets/js/87.3c405fd4.js"><link rel="prefetch" href="/assets/js/88.3194fb3a.js"><link rel="prefetch" href="/assets/js/89.75e0b6a6.js"><link rel="prefetch" href="/assets/js/9.5a5ce3e7.js"><link rel="prefetch" href="/assets/js/90.35949c5d.js"><link rel="prefetch" href="/assets/js/91.0cce381f.js"><link rel="prefetch" href="/assets/js/92.19316dc8.js"><link rel="prefetch" href="/assets/js/93.ebe6614c.js"><link rel="prefetch" href="/assets/js/94.2e3911e2.js"><link rel="prefetch" href="/assets/js/95.10189804.js"><link rel="prefetch" href="/assets/js/96.00ed890b.js"><link rel="prefetch" href="/assets/js/97.843b936f.js"><link rel="prefetch" href="/assets/js/98.6ffc4296.js"><link rel="prefetch" href="/assets/js/99.8272e00c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a8571fce.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/EB-logo.png" alt="YuKang's blog" class="logo"> <span class="site-name can-hide">YuKang's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/pages/802a1ca6f7b71c59/" class="nav-link">Vue</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》笔记</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》笔记</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》学习笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/pages/beb6c0bd8a66cea6/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/beb6c0bd8a66cea6/" class="nav-link">网站</a></li><li class="dropdown-item"><!----> <a href="/pages/eee83a9211a70f9d/" class="nav-link">资源</a></li><li class="dropdown-item"><!----> <a href="/pages/12df8ace52d493f6/" class="nav-link">Vue资源</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/dakang824" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://dakang824.github.io/imgs/folder_a/132.jpg"> <div class="blogger-info"><h3>YU Kang</h3> <span>前端界的小学生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/pages/802a1ca6f7b71c59/" class="nav-link">Vue</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》笔记</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》笔记</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》学习笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/pages/beb6c0bd8a66cea6/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/beb6c0bd8a66cea6/" class="nav-link">网站</a></li><li class="dropdown-item"><!----> <a href="/pages/eee83a9211a70f9d/" class="nav-link">资源</a></li><li class="dropdown-item"><!----> <a href="/pages/12df8ace52d493f6/" class="nav-link">Vue资源</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/dakang824" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/aea6571b7a8bae86/" class="sidebar-link">面试套路集锦</a></li><li><a href="/pages/aea6571b444/" aria-current="page" class="active sidebar-link">前端常见技术面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#html-css" class="sidebar-link">HTML + CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#标签语义化的意义" class="sidebar-link">标签语义化的意义</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#写页面结构应该注意的" class="sidebar-link">写页面结构应该注意的</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#html5-新特性" class="sidebar-link">HTML5 新特性</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#盒模型" class="sidebar-link">盒模型</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#bfc-box-formatting-context" class="sidebar-link">BFC (Box Formatting Context)</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#选择器优先级" class="sidebar-link">选择器优先级</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#去除浮动影响，防止父级高度塌陷" class="sidebar-link">去除浮动影响，防止父级高度塌陷</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#link-与-import-的区别" class="sidebar-link">link 与 @import 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#css-预处理器-sass-less-postcss" class="sidebar-link">CSS 预处理器(Sass/Less/Postcss)</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#单行文本溢出" class="sidebar-link">单行文本溢出</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#多行文本溢出" class="sidebar-link">多行文本溢出</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#flex-布局" class="sidebar-link">flex 布局</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#圣杯布局" class="sidebar-link">圣杯布局</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#双飞翼布局" class="sidebar-link">双飞翼布局</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#js-基础和高级" class="sidebar-link">JS 基础和高级</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#typeof-能判断什么" class="sidebar-link">typeof 能判断什么?</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#基本数据类型和引用数据类型" class="sidebar-link">基本数据类型和引用数据类型</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#字符串强转数字" class="sidebar-link">字符串强转数字</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#面向对象" class="sidebar-link">面向对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#异步相关" class="sidebar-link">异步相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#单线程与异步" class="sidebar-link">单线程与异步</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#同步与异步" class="sidebar-link">同步与异步</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#event-loop1-全宏任务" class="sidebar-link">event loop1(全宏任务)</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#宏任务与微任务" class="sidebar-link">宏任务与微任务</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#宏队列与微队列" class="sidebar-link">宏队列与微队列</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#event-loop2-宏任务-微任务" class="sidebar-link">event loop2(宏任务 &amp; 微任务)</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#promise-的理解" class="sidebar-link">Promise 的理解</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#promise-的-then-的理解" class="sidebar-link">promise 的 then()的理解</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#promise-all" class="sidebar-link">Promise.all()</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#async-await-与-promise-的关系" class="sidebar-link">async/await 与 promise 的关系</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#综合性执行流程题" class="sidebar-link">综合性执行流程题</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#es6" class="sidebar-link">ES6+</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#var-const-let-的区别" class="sidebar-link">var, const, let 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#箭头函数的特点" class="sidebar-link">箭头函数的特点</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#说说在项目中使用的-es6-语法" class="sidebar-link">说说在项目中使用的 ES6 语法?</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#web-api" class="sidebar-link">Web API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#事件冒泡与事件委托" class="sidebar-link">事件冒泡与事件委托</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#window-onload-和-document-ready-区别" class="sidebar-link">window.onload 和\$(document).ready()区别</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#前台数据存储" class="sidebar-link">前台数据存储</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#ajax" class="sidebar-link">ajax</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#restless-api-与-restful-api" class="sidebar-link">Restless API 与 Restful API</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#网页输入网址后经历了哪些过程" class="sidebar-link">网页输入网址后经历了哪些过程</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#post-常用的数据格式-form-data-和-json-的区别" class="sidebar-link">post 常用的数据格式,form-data 和 json 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#图片懒加载原理-如何实现" class="sidebar-link">图片懒加载原理,如何实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#手写代码-也可能让你说" class="sidebar-link">手写代码(也可能让你说)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#深拷贝" class="sidebar-link">深拷贝</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#数组相关" class="sidebar-link">数组相关</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#函数相关" class="sidebar-link">函数相关</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#字符串处理" class="sidebar-link">字符串处理</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#git-操作" class="sidebar-link">git 操作</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#webpack" class="sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#基础" class="sidebar-link">基础</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#其他配置" class="sidebar-link">其他配置</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#兼容性处理" class="sidebar-link">兼容性处理</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#摇树（tree-shaking）" class="sidebar-link">摇树（tree shaking）</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#缓存" class="sidebar-link">缓存</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#关闭-map-vue-项目生产环境" class="sidebar-link">关闭 map(vue 项目生产环境)</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#vue-基础" class="sidebar-link">Vue 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#组件间通信的方式" class="sidebar-link">组件间通信的方式</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#computed-与-method-和-watch-的区别" class="sidebar-link">computed 与 method 和 watch 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#如何理解-vue-的渐进式" class="sidebar-link">如何理解 vue 的渐进式</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#自定义指令" class="sidebar-link">自定义指令</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#vuex-和-redux-的区别" class="sidebar-link">vuex 和 redux 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#mvvm" class="sidebar-link">MVVM</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#vue-数据流" class="sidebar-link">Vue 数据流</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#数据劫持-数据绑定" class="sidebar-link">数据劫持-数据绑定</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#vue-实例的生命周期函数" class="sidebar-link">Vue 实例的生命周期函数</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#为什么组件中的-data-必须是函数形式？" class="sidebar-link">为什么组件中的 data 必须是函数形式？</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#路由" class="sidebar-link">路由</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#导航守卫（路由守卫）" class="sidebar-link">导航守卫（路由守卫）</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#路由懒加载" class="sidebar-link">路由懒加载</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#vue-use" class="sidebar-link">Vue.use</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#打包相关" class="sidebar-link">打包相关</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#vue-前台项目问题" class="sidebar-link">Vue 前台项目问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#路由跳转与传参相关问题" class="sidebar-link">路由跳转与传参相关问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#解决在二层及以上的路由路径上刷新-丢失-reset-样式的问题" class="sidebar-link">解决在二层及以上的路由路径上刷新, 丢失 reset 样式的问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#对-axios-进行二次封装（面试必说）" class="sidebar-link">对 axios 进行二次封装（面试必说）</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#测试调用接口请求函数（跨域问题）" class="sidebar-link">测试调用接口请求函数（跨域问题）</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#利用-lodash-进行函数节流处理" class="sidebar-link">利用 lodash 进行函数节流处理</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#优化减少组件对象数量" class="sidebar-link">优化减少组件对象数量</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#优化事件处理效率" class="sidebar-link">优化事件处理效率</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#利用标签-data-自定义属性携带动态数据" class="sidebar-link">利用标签 data 自定义属性携带动态数据</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#mock-接口数据" class="sidebar-link">Mock 接口数据</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#使用-swiper" class="sidebar-link">使用 swiper</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#响应式数据对象" class="sidebar-link">响应式数据对象</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#自定义分页组件-pagination" class="sidebar-link">自定义分页组件: Pagination</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#vue-后台项目的重要点" class="sidebar-link">Vue 后台项目的重要点</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#react-基础" class="sidebar-link">React 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#基础-2" class="sidebar-link">基础</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#面试" class="sidebar-link">面试</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#深入理解-setstate" class="sidebar-link">深入理解 setState</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#移动端" class="sidebar-link">移动端</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#基础知识" class="sidebar-link">基础知识</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#适配" class="sidebar-link">适配</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#移动端事件" class="sidebar-link">移动端事件</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#移动端中-touchstart-touchend-click-执行顺序" class="sidebar-link">移动端中 touchstart,touchend,click 执行顺序</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#点击穿透" class="sidebar-link">点击穿透</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#getcomputedstyle" class="sidebar-link">getComputedStyle</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#小程序" class="sidebar-link">小程序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_1-小程序特点" class="sidebar-link">1. 小程序特点</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_2-小程序适配" class="sidebar-link">2. 小程序适配</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_3-小程序相关语法" class="sidebar-link">3. 小程序相关语法</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_4-向事件对象传参" class="sidebar-link">4. 向事件对象传参</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#小程序获取用户唯一标识（openid）" class="sidebar-link">小程序获取用户唯一标识（openId）</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#小程序支付流程" class="sidebar-link">小程序支付流程</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#面试问题" class="sidebar-link">面试问题</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#开发相关" class="sidebar-link">开发相关</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#express" class="sidebar-link">express</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_1-基本使用" class="sidebar-link">1. 基本使用</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_2-路由" class="sidebar-link">2. 路由</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_3-路由参数" class="sidebar-link">3. 路由参数</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_4-res-常用方法" class="sidebar-link">4. res 常用方法</a></li><li class="sidebar-sub-header"><a href="/pages/aea6571b444/#_5-中间件" class="sidebar-link">5. 中间件</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>心情杂货</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实用技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/friends/" class="sidebar-link">友情链接</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-33863c7e><div class="articleInfo" data-v-33863c7e><ul class="breadcrumbs" data-v-33863c7e><li data-v-33863c7e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-33863c7e></a></li> <li data-v-33863c7e><a href="/more" title="更多-目录页" data-v-33863c7e>更多</a></li> <li data-v-33863c7e><a href="/more/#面试" title="更多#面试" data-v-33863c7e>面试</a></li> <!----></ul> <div class="info" data-v-33863c7e><div title="作者" class="author iconfont icon-touxiang" data-v-33863c7e><a href="https://github.com/xugaoyi" target="_blank" title="作者" class="beLink" data-v-33863c7e>yukang</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-33863c7e><a href="javascript:;" data-v-33863c7e>2021-01-11</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">
          前端常见技术面试
        </h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="前端常见技术面试"><a href="#前端常见技术面试" class="header-anchor">#</a> 前端常见技术面试</h1> <h2 id="html-css"><a href="#html-css" class="header-anchor">#</a> HTML + CSS</h2> <h3 id="标签语义化的意义"><a href="#标签语义化的意义" class="header-anchor">#</a> 标签语义化的意义</h3> <ol><li>开发者更容易理解，减少差异化，方便团队开发和维护</li> <li>机器更容易理解结果（搜索爬虫、方便其他设备解析（读屏幕软件、盲人设备、移动设备）</li></ol> <h3 id="写页面结构应该注意的"><a href="#写页面结构应该注意的" class="header-anchor">#</a> 写页面结构应该注意的</h3> <ol><li>尽可能少的使用没有语义的 div 和 span 元素</li> <li>块级元素和内联元素的嵌套一定要符合 web 标准，比如内联元素就是不能嵌套块级元素</li></ol> <h3 id="html5-新特性"><a href="#html5-新特性" class="header-anchor">#</a> HTML5 新特性</h3> <ol><li>新的语义化元素：article 、footer 、header 、nav 、section</li> <li>表单增强，新的表单控件：calendar 、date 、time 、email 、url 、search</li> <li>新的 API：音频(用于媒介回放的 video 和 audio 元素)、图形（绘图 canvas 元素）</li> <li>新的 API：离线，通过创建 cache manifest 文件，创建应用程序缓存</li> <li>新的 API：本地存储，localStorage-没有时间限制的数据存储，sessionStorage-session 数据存储（关闭浏览器窗口数据删除）</li> <li>新的 API：实时通讯，设备能力</li></ol> <h3 id="盒模型"><a href="#盒模型" class="header-anchor">#</a> 盒模型</h3> <p>页面渲染时，dom 元素所采用的 <strong>布局模型</strong>。可通过<code>box-sizing</code>进行设置。根据计算宽高的区域可分为：</p> <ul><li><code>content-box</code> (W3C 标准盒模型)</li> <li><code>border-box</code> (IE 盒模型)</li> <li><code>padding-box</code></li> <li><code>margin-box</code> (浏览器未实现)</li></ul> <h3 id="bfc-box-formatting-context"><a href="#bfc-box-formatting-context" class="header-anchor">#</a> BFC (Box Formatting Context)</h3> <p><strong>块级格式化上下文</strong>，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p> <blockquote><p>IE 下为 Layout，可通过 zoom:1 触发</p></blockquote> <ul><li><p>触发条件:</p> <ul><li>根元素</li> <li><code>position: absolute/fixed</code></li> <li><code>display: inline-block / table</code></li> <li><code>float</code> 元素</li> <li><code>ovevflow</code> !== <code>visible</code></li></ul></li> <li><p>规则:</p> <ul><li>属于同一个 BFC 的两个相邻 Box 垂直排列</li> <li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li> <li>BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)</li> <li>BFC 的区域不会与 float 的元素区域重叠</li> <li>计算 BFC 的高度时，浮动子元素也参与计算 - 文字层不会被浮动层覆盖，环绕于周围</li></ul></li> <li><p>应用:</p> <ul><li>阻止<code>margin</code>重叠</li> <li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个<code>div</code>都位于同一个 BFC 区域之中)</li> <li>自适应两栏布局</li> <li>可以阻止元素被浮动元素覆盖</li></ul></li></ul> <h3 id="选择器优先级"><a href="#选择器优先级" class="header-anchor">#</a> 选择器优先级</h3> <ul><li><code>!important</code> &gt; 行内样式 &gt; <code>#id</code> &gt; <code>.class</code> &gt; <code>tag</code> &gt; * &gt; 继承 &gt; 默认</li> <li>选择器 <strong>从右往左</strong> 解析</li></ul> <h3 id="去除浮动影响，防止父级高度塌陷"><a href="#去除浮动影响，防止父级高度塌陷" class="header-anchor">#</a> 去除浮动影响，防止父级高度塌陷</h3> <ul><li>通过增加标签清除浮动<code>.clear{clear:both} &lt;div class='clear'&gt;&lt;div&gt;</code></li> <li>使用伪类元素<code>:after / &lt;br&gt; : clear: both</code></li> <li>创建父级 BFC</li> <li>父级设置高度或者添加 overflow: hidden;</li></ul> <h3 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="header-anchor">#</a> link 与 @import 的区别</h3> <ul><li><code>link</code>功能较多，可以定义 RSS，定义 Rel 等作用，而<code>@import</code>只能用于加载 css</li> <li>当解析到<code>link</code>时，页面会同步加载所引的 css，而<code>@import</code>所引用的 css 会等到页面加载完才被加载</li> <li><code>@import</code>需要 IE5 以上才能使用</li> <li><code>link</code>可以使用 js 动态引入，<code>@import</code>不行</li></ul> <h3 id="css-预处理器-sass-less-postcss"><a href="#css-预处理器-sass-less-postcss" class="header-anchor">#</a> CSS 预处理器(Sass/Less/Postcss)</h3> <p>CSS 预处理器的原理: 是将类 CSS 语言通过 <strong>Webpack 编译</strong> 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能:</p> <ul><li>嵌套</li> <li>变量</li> <li>循环语句</li> <li>条件语句</li> <li>自动前缀</li> <li>单位转换</li> <li>mixin 复用</li></ul> <h3 id="单行文本溢出"><a href="#单行文本溢出" class="header-anchor">#</a> <strong>单行文本溢出</strong></h3> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>
<span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="多行文本溢出"><a href="#多行文本溢出" class="header-anchor">#</a> <strong>多行文本溢出</strong></h3> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
<span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>
<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span> <span class="token comment">/*2*/</span>
<span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="flex-布局"><a href="#flex-布局" class="header-anchor">#</a> flex 布局</h3> <ul><li>flex:1，单独给某一个子元素设置 flex 属性的时候可以提高当前 flex 的权重</li></ul> <h3 id="圣杯布局"><a href="#圣杯布局" class="header-anchor">#</a> 圣杯布局</h3> <ul><li>圣杯特点简单记为：有头、有尾、包三列，圣杯布局中间有 container 大容器包裹着左、中、右三列区域</li> <li>左、中、右是独立的三个区域，都处于一个层级</li></ul> <h3 id="双飞翼布局"><a href="#双飞翼布局" class="header-anchor">#</a> 双飞翼布局</h3> <ul><li>左、中、右是独立的三个区域，中间区域属于最上面的层级</li></ul> <h2 id="js-基础和高级"><a href="#js-基础和高级" class="header-anchor">#</a> JS 基础和高级</h2> <h3 id="typeof-能判断什么"><a href="#typeof-能判断什么" class="header-anchor">#</a> typeof 能判断什么?</h3> <ul><li>识别所有基本类型(null 除外)</li> <li>识别函数</li> <li>识别是不是引用类型(不可再细分对象还是数组)</li></ul> <h3 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="header-anchor">#</a> 基本数据类型和引用数据类型</h3> <ul><li>7 种基本数据类型:Null Undefined Number Boolean String Symbol Bigint</li> <li>1 中引用数据类型:Object</li></ul> <h3 id="字符串强转数字"><a href="#字符串强转数字" class="header-anchor">#</a> 字符串强转数字</h3> <ul><li>+号</li> <li>*1</li> <li><code>'123'&gt;&gt;&gt;0</code>位移符，先转二进制向右位移，左边不足的位用 0 补齐</li></ul> <h3 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> <strong>面向对象</strong></h3> <h4 id="作用域"><a href="#作用域" class="header-anchor">#</a> <strong>作用域</strong></h4> <ol><li><p>什么是作用域</p> <p>用来规定代码作用的范围及变量查询的范围</p></li> <li><p>作用域的作用</p> <p>隔离变量, 防止命名冲突</p></li> <li><p>作用域什么时候产生及销毁</p> <ul><li><p>代码定义的时候产生</p></li> <li><p>函数执行完销毁的是变量对象而不是作用域</p></li> <li><p>作用域从代码定义的时候就一直在，除非没有当前代码</p></li></ul></li> <li><p><strong>作用域链</strong></p> <ul><li>查找变量的时候先在当前作用域的变量对象中查找，如果有就使用，如果没有会继续去上级作用域查找，直到找到全局作用域，如果还没有就报错，报错内容： xxx is not defined, 查找的过程就是沿着作用域链查找</li> <li>本质: 是一个数组，数组包含上级所有的变量对象</li></ul></li></ol> <h4 id="执行上下文环境"><a href="#执行上下文环境" class="header-anchor">#</a> <strong>执行上下文环境</strong></h4> <p>js 代码在正式执行之前 js 引擎会先做一些准备工作</p> <ol><li>创建执行上下文环境</li> <li>创建一个空的对象(执行上下文对象)，该对象用于收集当前作用域的：变量，函数，函数的参数</li> <li>确认 this 的指向</li> <li>创建当前环境的作用域链</li></ol> <h4 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h4> <ul><li><p><strong>闭包的形成条件</strong></p> <ol><li><p>函数嵌套</p></li> <li><p>内部函数引用外部函数的局部变量</p></li> <li><p>调用外部函数, 执行内部函数定义</p> <p>注意: 如果外部函数执行完后, 内部函数对象如果没有被外部变量引用, 内部函数对象与闭包就会立即被回收释放</p></li></ol></li> <li><p><strong>什么是闭包</strong></p> <ol><li>闭包是抽象的概念</li> <li>闭包其实指的就是满足一定的条件下(闭包的形成条件)，会形成一个闭包的容器(非 js 对象)</li> <li>该对象用于收集内部函数使用的外部函数的变量</li> <li>该对象在内部函数调用的时候供内部函数使用</li> <li>因为闭包形成的闭合对象保存在内部函数的[[scopes]]中</li></ol></li></ul> <h4 id="this-在不同场景下的取值"><a href="#this-在不同场景下的取值" class="header-anchor">#</a> this 在不同场景下的取值?</h4> <ul><li><p>this 学习的 2 个目标:</p> <ul><li><strong>能判断出函数中的 this 是谁</strong></li> <li><strong>能控制函数的 this 是需要的特定对象</strong></li></ul></li> <li><p>常规情况下, 函数中的 this 取决于执行函数的方式</p> <ul><li>fn(): 直接调用 ==&gt; <strong>this 是?</strong> window</li> <li>new fn(): new 调用 ==&gt; <strong>this 是?</strong> 新建的对象</li> <li>obj.fn(): 通过对象调用 ==&gt; <strong>this 是?</strong> obj</li> <li>fn.call/apply(obj): 通过函数对象的 call/apply 来调用 ==&gt; <strong>this 是?</strong> obj</li></ul></li> <li><p>特殊情况:</p> <ul><li>bind(obj)返回的函数 ==&gt; <strong>this 是?</strong> obj</li> <li>箭头函数 ==&gt; <strong>this 是?</strong> 外部作用域的 this</li> <li>回调函数
<ul><li>定时器/ajax/promise/数组遍历相关方法回调 ==&gt; <strong>this 是?</strong> window</li> <li>vue 控制的回调函数 ==&gt; <strong>this 是?</strong> 组件的实例</li> <li>React 控制的生命周期回调, 事件监听回调 ==&gt; <strong>this 是?</strong> 组件对象 / undefined</li></ul></li></ul></li> <li><p>如何控制函数的 this?</p> <ul><li>利用函数的 bind()</li> <li>利用箭头函数</li> <li>也可以用外部保存了 this 的变量</li></ul></li></ul> <h4 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h4> <ul><li><p><strong>什么是原型对象</strong></p> <ol><li><p>每个函数的 prototype 指向的是其显示原型对象</p></li> <li><p>每个实例的<code>__proto__</code>指向的是其隐式原型对象</p></li> <li><p>实例的隐式原型对象 === 其构造函数的显示原型对象</p></li></ol></li> <li><p><strong>原型链</strong></p> <ol><li>对象查找属性的时候现在自身查找，如果自身没有沿着<code>__proto__</code>这条链查找</li> <li>如果有就使用，如果没有就继续向上查找直到找到 Object.prototype，如果还没有就返回 undefined</li></ol></li> <li><p><strong>原型继承</strong></p> <ol><li>子类的原型成为父类的实例</li> <li>需要执行子类的构造属性 constructor</li></ol></li> <li><p><strong>借用构造函数继承</strong></p> <p>不是真正意义上的继承，只是简化子类构造函数的代码</p></li> <li><p>组合继承</p> <p>原型继承 + 借用构造函数继承</p></li></ul> <h2 id="异步相关"><a href="#异步相关" class="header-anchor">#</a> 异步相关</h2> <h3 id="单线程与异步"><a href="#单线程与异步" class="header-anchor">#</a> 单线程与异步</h3> <ul><li>JS 是单线程编程语言, 只能同时做一件事</li> <li>浏览器和 nodejs 已支持 JS 启动分线程, 如: Web Worker</li> <li>JS 和 DOM 渲染共用主线程, 因为 JS 可以修改 DOM 结构</li> <li>遇到需要等待 (网络请求, 定时任务) 不能卡住</li> <li>需要异步</li> <li>回调 callback 函数</li></ul> <h3 id="同步与异步"><a href="#同步与异步" class="header-anchor">#</a> 同步与异步</h3> <ul><li>基于 JS 是单线程编程语言</li> <li>同步会阻塞代码执行</li> <li>异步不会阻塞代码执行</li></ul> <h3 id="event-loop1-全宏任务"><a href="#event-loop1-全宏任务" class="header-anchor">#</a> event loop1(全宏任务)</h3> <ul><li>js 是单线程运行的</li> <li>异步要基于回调来实现</li> <li>event loop 就是异步回调的实现原理</li></ul> <p>事件循环机制的 2 个重要部分</p> <p>​ 在分线程执行的管理模块: 定时器/ajax/dom 事件</p> <p>​ 保存待执行的回调函数的事件队列</p> <h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="header-anchor">#</a> 宏任务与微任务</h3> <ul><li>JS 执行有同步任务队列和等待任务队列,异步任务都是谁先到达条件谁先执行，但是谁先到达执行条件也有优先级的问题，这个优先级要看这个任务是宏任务还是微任务；<strong>微任务的优先级比宏任务的要高</strong>；</li> <li>宏任务: setTimeout, setInterval, Ajax, DOM 事件监听</li> <li>微任务: <strong>Promise 的 then 的回调函数, async 函数 await 下面的代码</strong>, mutationobserver(H5),process.nextTick</li> <li>执行顺序: 同步任务队列-&gt;微任务-&gt;宏任务</li></ul> <p><img src="https://img-blog.csdnimg.cn/2019071514332475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTU5Njc3,size_16,color_FFFFFF,t_70" alt="event loop"></p> <h3 id="宏队列与微队列"><a href="#宏队列与微队列" class="header-anchor">#</a> 宏队列与微队列</h3> <ul><li>宏队列: 用来保存 n 个宏任务的队列容器</li> <li>微队列: 用来保存 n 个微任务的队列容器</li></ul> <h3 id="event-loop2-宏任务-微任务"><a href="#event-loop2-宏任务-微任务" class="header-anchor">#</a> event loop2(宏任务 &amp; 微任务)</h3> <ul><li><p>js-web 中的 dom 事件回调, 定时器回调与 ajax 回调异步执行, 都是基于 event loop ===&gt; 宏任务</p></li> <li><p>H5 新的 MutationObserver 也基于 event loop ==&gt; 微任务</p></li> <li><p>promise 成功和失败的回调也是异步执行的, 也是基于 event loop ==&gt; 微任务</p></li> <li><p>执行顺序:</p> <ul><li>第一步: 先执行 script 下的所有同步代码</li> <li>第二步: 再依次取出微列中的所有微任务执行</li> <li>第三步: 再取出宏队列中第一个宏任务执行</li> <li>再循环第二步与第三步</li></ul> <p><img src="https://img-blog.csdnimg.cn/20190715163003797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTU5Njc3,size_16,color_FFFFFF,t_70" alt="event loop"></p></li></ul> <h3 id="promise-的理解"><a href="#promise-的理解" class="header-anchor">#</a> Promise 的理解</h3> <ul><li>ES6 推出的新的更好的异步编程解决方案(相对于纯回调的方式)
<ul><li>可以异步操作启动后或完成后, 再指定回调函数得到异步结果数据</li> <li>解决嵌套回调的回调地狱问题 ---promise 链式调用</li></ul></li> <li>promise 对象有 3 种状态
<ul><li>pending</li> <li>resolved/fulfilled</li> <li>rejected</li></ul></li> <li>promise 状态的 2 种变化
<ul><li>pending --&gt; resolved</li> <li>pending --&gt; rejected</li> <li>注意: 变化是不可逆</li></ul></li></ul> <h3 id="promise-的-then-的理解"><a href="#promise-的-then-的理解" class="header-anchor">#</a> promise 的 then()的理解</h3> <ul><li>then()总是返回一个新的 promise</li> <li>新 promise 的结果状态由 then 指定的回调函数执行的结果决定
<ul><li>抛出错误</li> <li>返回失败的 promise</li> <li>返回成功的 promise</li> <li>返回其它任何值</li></ul></li></ul> <h3 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> Promise.all()</h3> <ul><li>语法: Promise.all([promise1, promise2, promise3])</li> <li>批量/一次性发送多个异步请求</li> <li>当都成功时, 返回的 promise 才成功</li> <li>一旦有一个失败的, 返回的 promise 就失败了</li></ul> <h3 id="async-await-与-promise-的关系"><a href="#async-await-与-promise-的关系" class="header-anchor">#</a> async/await 与 promise 的关系</h3> <ul><li>async/await 是消灭异步回调的终极武器</li> <li>作用: 简化 promise 对象的使用, 不用再使用 then/catch 来指定回调函数</li> <li>但和 Promise 并不互斥</li> <li>反而, 两者相辅相成</li> <li>执行 async 函数, 返回 promise 对象</li> <li>await 相当于 promise 的 then</li> <li>try...catch 可捕获异常, 相当于 promise 的 catch</li></ul> <h3 id="综合性执行流程题"><a href="#综合性执行流程题" class="header-anchor">#</a> 综合性执行流程题</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;6&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;7&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 1 7 2 3 8 4 6 5 0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h2 id="es6"><a href="#es6" class="header-anchor">#</a> ES6+</h2> <h3 id="var-const-let-的区别"><a href="#var-const-let-的区别" class="header-anchor">#</a> var, const, let 的区别</h3> <ul><li>const 定义常量, let/var 定义变量</li> <li>const 和 let 相对于 var
<ul><li>有块作用域</li> <li>没有变量提升</li> <li>不会添加到 window 上</li> <li>不能重复声明</li></ul></li></ul> <h3 id="箭头函数的特点"><a href="#箭头函数的特点" class="header-anchor">#</a> 箭头函数的特点</h3> <ul><li>没有自己的 this, 使用外部作用域中的 this, 不能通过 bind 来绑定 this</li> <li>不能通过 new 来创建实例对象</li> <li>内部没有 arguments, 可以通过 rest 参数来代替</li></ul> <h3 id="说说在项目中使用的-es6-语法"><a href="#说说在项目中使用的-es6-语法" class="header-anchor">#</a> 说说在项目中使用的 ES6 语法?</h3> <ul><li>新的语法:
<ul><li>const / let</li> <li>解构赋值</li> <li>模板字符串</li> <li>箭头函数 / 形参默认值 / rest 参数</li> <li>扩展运算符(...)拆解数组或对象</li> <li>模板化相关语法</li></ul></li> <li>新的 API
<ul><li>Array.from() / Array.of()</li> <li>arr.find() / arr.flat()</li> <li>string.includes()</li> <li>promise ==&gt; async &amp; await ==&gt; 异步封装 / ajax 请求</li> <li>Map, Set ===&gt; 解决深拷贝循环引用的问题, 数组去重</li> <li>Proxy 与 Reflect ===&gt; Vue3 内部用来实现数据响应式</li></ul></li></ul> <h2 id="web-api"><a href="#web-api" class="header-anchor">#</a> Web API</h2> <h3 id="事件冒泡与事件委托"><a href="#事件冒泡与事件委托" class="header-anchor">#</a> 事件冒泡与事件委托</h3> <h4 id="_1-事件冒泡的流程"><a href="#_1-事件冒泡的流程" class="header-anchor">#</a> 1) 事件冒泡的流程</h4> <ul><li>基于 DOM 树形结构</li> <li>事件在目标元素上处理后, 会由内向外(上)逐层传递</li> <li>应用场景: 事件代理/委托/委派</li></ul> <h4 id="_2-事件委托"><a href="#_2-事件委托" class="header-anchor">#</a> 2) 事件委托</h4> <ul><li>减少内存占用(事件监听回调从 n 变为 1)</li> <li>动态添加的内部元素也能响应</li> <li>代码简洁</li> <li>不要滥用</li></ul> <h3 id="window-onload-和-document-ready-区别"><a href="#window-onload-和-document-ready-区别" class="header-anchor">#</a> window.onload 和$(document).ready()区别</h3> <ul><li>window.onload 是在待网页中所有内容加载完毕之后（包括图片）回调</li> <li>而$(documetn).ready()内部使用的是 DOMContentLoaded 监听, 在文档内容加载完成, 但图片还未加载加完前回调</li></ul> <h3 id="前台数据存储"><a href="#前台数据存储" class="header-anchor">#</a> 前台数据存储</h3> <h4 id="存储方式"><a href="#存储方式" class="header-anchor">#</a> 存储方式</h4> <ul><li><p>cookie</p></li> <li><p>sessionStorage</p></li> <li><p>localStorage</p> <p>注意: session 后台数据存储</p></li></ul> <h4 id="区别-localstoarge-与-sessionstorage"><a href="#区别-localstoarge-与-sessionstorage" class="header-anchor">#</a> 区别 localStoarge 与 sessionStorage</h4> <ul><li>相同点:
<ul><li>纯浏览器端存储, 大小不受限制, 请求时不会自动携带</li> <li>只能保存文本, 如果是对象或数组, 需要转换为 JSON</li> <li>API 相同:
<ul><li>setItem(key, value)</li> <li>getItem(key, value)</li> <li>removeitem(key, value)</li></ul></li> <li>浏览器不能禁用</li></ul></li> <li>不同点:
<ul><li>localStorage 保存在本地文件中, 除非编码或手动删除, 否则一直存在</li> <li>sessonStorage 数据保存在当前会话内存中, 关闭浏览器则清除</li></ul></li></ul> <h4 id="区别-cookie-与-localstorage-和-sessionstorage"><a href="#区别-cookie-与-localstorage-和-sessionstorage" class="header-anchor">#</a> 区别 cookie 与 localStorage 和 sessionStorage</h4> <ul><li>容量: cookie 小</li> <li>请求时是否自动携带: cookie 自动携带</li> <li>API 易用性: cookie 的操作语法不方便</li> <li>浏览器是否可禁用: cookie 可禁用</li></ul> <h4 id="区别-cookie-与-session"><a href="#区别-cookie-与-session" class="header-anchor">#</a> 区别 cookie 与 session</h4> <ul><li>cookie 保存在浏览器端(前台可以操作)</li> <li>session 保存在服务器端(前台不能操作)</li> <li>session 依赖于 cookie(session 的 id 以 cookie 的形式保存在浏览器端)</li></ul> <h3 id="ajax"><a href="#ajax" class="header-anchor">#</a> ajax</h3> <h4 id="xhr-status-响应状态码"><a href="#xhr-status-响应状态码" class="header-anchor">#</a> xhr.status: 响应状态码</h4> <ul><li>2XX: 表示成功处理请求,
<ul><li>200: 成功</li> <li>201: 添加数据成功</li></ul></li> <li>3XX: 需要生定向, 浏览器直接跳转,
<ul><li>302: 自动重定向到指定 url</li></ul></li> <li>4XX: 客户端请求错误, 如:
<ul><li>401: 没有访问的权限</li> <li>404 : 访问的资源不存在</li></ul></li> <li>5XX: 服务器端错误
<ul><li>500: 服务器端程序运行出错了</li></ul></li></ul> <h4 id="区别-ajax-请求与一般-http-请求"><a href="#区别-ajax-请求与一般-http-请求" class="header-anchor">#</a> 区别 ajax 请求与一般 HTTP 请求</h4> <ul><li>ajax 请求是一种特别的 http 请求</li> <li>对服务器端来说, 没有任何区别, 区别在浏览器端</li> <li>浏览器端发请求: 只有 XHR 或 fetch 发出的才是 ajax 请求, 其它所有的都是非 ajax 请求</li> <li>浏览器端接收到响应
<ul><li>一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面</li> <li>ajax 请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据</li></ul></li></ul> <h4 id="封装一个简易的-ajax-异步请求函数"><a href="#封装一个简易的-ajax-异步请求函数" class="header-anchor">#</a> 封装一个简易的 ajax 异步请求函数</h4> <h5 id="简洁版-必须"><a href="#简洁版-必须" class="header-anchor">#</a> 简洁版(必须)</h5> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 
xhr + promise 封装一个异步ajax请求的通用函数  简洁版
*/</span>
<span class="token keyword">function</span> <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个XHR对象</span>
    <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化一个异步请求(还没发请求)</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果状态值不为4, 直接结束(请求还没有结束)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 如果响应码在200~~299之间, 说明请求都是成功的</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 指定promise成功及结果值</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 请求失败了</span>
        <span class="token comment">// 指定promise失败及结果值</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;request error staus &quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h5 id="加强版-可选"><a href="#加强版-可选" class="header-anchor">#</a> 加强版(可选)</h5> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 
xhr + promise 封装一个异步ajax请求的通用函数  加强版
  返回值: promise
  参数为配置对象
    url: 请求地址
    params: 包含所有query请求参数的对象
    data: 包含所有请求体参数数据的对象
    method: 为请求方式
*/</span>
<span class="token keyword">function</span> <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token string">&quot;GET&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回一个promise对象</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个XHR对象</span>
    <span class="token keyword">const</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 根据params拼接query参数</span>
    <span class="token keyword">let</span> queryStr <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      pre <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&amp;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>queryStr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      queryStr <span class="token operator">=</span> queryStr<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      url <span class="token operator">+=</span> <span class="token string">&quot;?&quot;</span> <span class="token operator">+</span> queryStr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 请求方式转换为大写</span>
    method <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 初始化一个异步请求(还没发请求)</span>
    request<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定请求状态改变的监听</span>
    request<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果状态值不为4, 直接结束(请求还没有结束)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 如果响应码在200~~299之间, 说明请求都是成功的</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>status <span class="token operator">&gt;=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 准备响应数据对象</span>
        <span class="token keyword">const</span> responseData <span class="token operator">=</span> <span class="token punctuation">{</span>
          data<span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">,</span>
          status<span class="token operator">:</span> request<span class="token punctuation">.</span>status<span class="token punctuation">,</span>
          statusText<span class="token operator">:</span> request<span class="token punctuation">.</span>statusText<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 指定promise成功及结果值</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>responseData<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 请求失败了</span>
        <span class="token comment">// 指定promise失败及结果值</span>
        <span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;request error staus &quot;</span> <span class="token operator">+</span> request<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果是post/put请求</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">===</span> <span class="token string">&quot;POST&quot;</span> <span class="token operator">||</span> method <span class="token operator">===</span> <span class="token string">&quot;PUT&quot;</span> <span class="token operator">||</span> method <span class="token operator">===</span> <span class="token string">&quot;DELETE&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 设置请求头: 使请求体参数以json形式传递</span>
      request<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span>
        <span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">,</span>
        <span class="token string">&quot;application/json;charset=utf-8&quot;</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 包含所有请求参数的对象转换为json格式</span>
      <span class="token keyword">const</span> dataJson <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 发送请求, 指定请求体数据</span>
      request<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>dataJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// GET请求</span>
      <span class="token comment">// 发送请求</span>
      request<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br></div></div><h4 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h4> <ul><li>什么是跨域(同源策略)</li> <li>JSONP</li> <li>CORS</li> <li>代理服务器</li></ul> <h4 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略</h4> <ul><li>同源: 协议, 域名, 端口, 三者都相同</li> <li>ajax 请求时, 浏览器要求当前网页和 Server 必须同源(安全), 否则会抛出跨域的错误</li> <li>加载 image/link/script 不受同源策略限制</li></ul> <h4 id="jsonp-原理"><a href="#jsonp-原理" class="header-anchor">#</a> JSONP 原理</h4> <ul><li><p>前台:</p> <ul><li><p><code>&lt;script src=&quot;目标url?callback=fn&quot; /&gt;</code></p></li> <li><p>接收响应数据的函数: function fn (data) {}</p></li></ul></li> <li><p>后台</p> <ul><li>处理请求, 产生需要返回的数据 data</li> <li>读取 callback 请求参数得到前台处理响应数据的函数名 fn</li> <li>返回执行函数 fn 的 js 代码: 'fn &amp;&amp; fn(data)'</li></ul></li> <li><p>不足</p> <ul><li>只能处理 GET 请求</li> <li>每个请求在后台都要做处理, 麻烦</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 发送jsonp请求的函数</span>
<span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;text/javascript&quot;</span><span class="token punctuation">;</span>
  <span class="token comment">// 传参并指定回调执行函数为backFn</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://localhost:4000/getUserInfo?id=100&amp;callback=cbFn&quot;</span><span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 回调函数, 接收响应数据</span>
<span class="token keyword">function</span> <span class="token function">cbFn</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div></li></ul> <h4 id="cors-原理"><a href="#cors-原理" class="header-anchor">#</a> CORS 原理</h4> <ul><li>后台: 返回允许浏览器在某个域上发送跨域请求的相关响应头</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 使用cors, 允许跨域, 且允许携带跨域cookie</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// console.log('----')</span>
  <span class="token comment">// 允许跨域的地址</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;http://localhost:5500&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不要是*</span>
  <span class="token comment">// 允许携带凭证(也就是cookie)</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Credentials&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 允许跨域的请求头</span>
  res<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 放行</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li>前台: 不需要做特别任何处理</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 允许携带cookie</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="代理服务器"><a href="#代理服务器" class="header-anchor">#</a> 代理服务器</h4> <ul><li>开发环境: 利用 webpack-dev-server 中的 http-proxy-middle 进行正向代理
<ul><li>vue 脚手架项目: vue.config.js</li> <li>react 脚手架项目: package.json</li></ul></li> <li>生产环境: 利用 nigix 进行反向代理</li></ul> <h4 id="使用-axios-发送-ajax-请求"><a href="#使用-axios-发送-ajax-请求" class="header-anchor">#</a> 使用 axios 发送 ajax 请求</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 发请求的基本语法</span>
<span class="token function">axios</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  method<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
  url<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
  params<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span> 配置 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token punctuation">{</span> 配置 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
axios<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token punctuation">{</span> 配置 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
axios<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span> 配置 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建新的axios</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  baseURL<span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
  timeout<span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加请求拦截器</span>
instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 添加请求头</span>
  config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">&quot;token&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> token值<span class="token punctuation">;</span>
  <span class="token keyword">return</span> config<span class="token punctuation">;</span> <span class="token comment">// 必须返回config</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加响应拦截器</span>
instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// return response</span>
    <span class="token keyword">return</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 请求某个具体的接口</span>
<span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token operator">:</span> <span class="token string">&quot;/xxx&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h3 id="restless-api-与-restful-api"><a href="#restless-api-与-restful-api" class="header-anchor">#</a> Restless API 与 Restful API</h3> <ul><li><p>Restless API</p> <ul><li>传统的 API, 把每个 url 当作一个功能操作 /updateUser</li> <li>同一个 url, 后台只进行 CRUD 的某一种操作</li> <li>请求方式不决定请求的 CRUD 操作</li> <li>一个请求路径只对应一个操作</li> <li>一般只有 GET/POST</li></ul></li> <li><p>Restful API</p> <ul><li>新式的 API, 把每个 url 当作一个唯一资源 /user/2</li> <li>同一个 url, 可以通过不同类型的请求对后台资源数据进行 CRUD 四种操作</li> <li>请求方式来决定了请求在后台进行 CRUD 的哪种操作
<ul><li>GET: 查询</li> <li>POST: 添加</li> <li>PUT: 更新</li> <li>DELETE: 删除</li></ul></li> <li>同一个请求路径可以进行多个操作</li> <li>请求方式会用到 GET/POST/PUT/DELETE</li></ul></li> <li><p>测试: 可以使用 json-server 快速搭建模拟的 rest api 接口</p></li></ul> <h3 id="网页输入网址后经历了哪些过程"><a href="#网页输入网址后经历了哪些过程" class="header-anchor">#</a> 网页输入网址后经历了哪些过程</h3> <h4 id="简单表达"><a href="#简单表达" class="header-anchor">#</a> 简单表达</h4> <ol><li>解析域名</li> <li>建立 TCP 连接</li> <li>浏览器发送请求到服务器，</li> <li>服务器处理请求返回响应给浏览器</li> <li>浏览器解析渲染页面</li> <li>断开 TCP 链接</li></ol> <h4 id="详细些表达"><a href="#详细些表达" class="header-anchor">#</a> 详细些表达</h4> <ol><li><strong>DNS 域名解析（查询）：将域名地址解析 ip 地址</strong></li></ol> <ul><li>浏览器 DNS 缓存</li> <li>计算机 DNS 缓存</li> <li>路由器 DNS 缓存</li> <li>网络运营商 DNS 缓存</li> <li>递归查询</li></ul> <ol start="2"><li><strong>建立 TCP 链接：TCP 三次握手</strong></li></ol> <ul><li>客户端发送服务端：我准备好了，请你准备一下</li> <li>服务端发送客户端：我也准备好了，请你确认一下</li> <li>客户端发送服务端：确认完毕</li></ul> <p><img src="D:/work/%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/code/note/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B_%E9%80%9A%E4%BF%97%E7%89%88.jpeg" alt="TCP三次握手_通俗版"></p> <ol start="3"><li><strong>发送请求</strong>给服务器端</li></ol> <ul><li>将请求报文发送过去</li></ul> <ol start="4"><li><strong>服务器端返回响应</strong></li></ol> <ul><li>将响应报文发送过来</li></ul> <ol start="5"><li><strong>解析渲染页面</strong></li></ol> <ul><li>遇到 HTML，调用 HTML 解析器，解析成 DOM 树</li> <li>遇到 CSS，调用 CSS 解析器，解析成 CSSOM 树</li> <li>遇到 JS，调用 JS 解析器（JS 引擎），解析 JS 代码
<ul><li>可能要修改元素节点，重新调用 HTML 解析器，解析成新 DOM 树</li> <li>可能要修改样式节点，重新调用 CSS 解析器，解析成新 CSSOM 树</li></ul></li> <li>将 DOM + CSSOM = Render Tree（渲染树）</li> <li>layout 布局：计算元素的位置和大小信息</li> <li>render 渲染：将颜色/文字/图片等渲染上去</li></ul> <ol start="6"><li><strong>断开链接：TCP 四次挥手</strong>
(断开请求链接 2 次, 断开响应链接 2 次)</li></ol> <ul><li>客户端发送服务端：请求数据发送完毕，可以断开了</li> <li>服务端发送客户端：请求数据接受完毕，可以断开了</li> <li>服务端发送客户端：响应数据发送完毕，可以断开了</li> <li>客户端发送服务端：响应数据接受完毕，可以断开了</li></ul> <h3 id="post-常用的数据格式-form-data-和-json-的区别"><a href="#post-常用的数据格式-form-data-和-json-的区别" class="header-anchor">#</a> post 常用的数据格式,form-data 和 json 的区别</h3> <ul><li>application/json: json 格式文本</li> <li>application/x-www-form-urlencoded: 形如 query 参数(name=tom&amp;age=12)的文本</li> <li>multipart/form-data: 文件上传</li></ul> <h3 id="图片懒加载原理-如何实现"><a href="#图片懒加载原理-如何实现" class="header-anchor">#</a> 图片懒加载原理,如何实现</h3> <ul><li><p>先将 img 标签中的 src 链接设置为空，将真正的图片链接放在自定义属性（data-src），</p></li> <li><p>当 js 监听到图片元素进入到可视窗口的时候，将自定义属性中的地址存储到 src 中，达到懒加载的效果</p></li></ul> <h2 id="手写代码-也可能让你说"><a href="#手写代码-也可能让你说" class="header-anchor">#</a> 手写代码(也可能让你说)</h2> <h3 id="深拷贝"><a href="#深拷贝" class="header-anchor">#</a> 深拷贝</h3> <ul><li>JSON.parse(JSON.stringfy(obj))
<ul><li>===&gt; 问题: 方法/函数会丢失</li> <li>===&gt; 问题 2: 循环引用会出错(死循环)</li></ul></li> <li>递归遍历
<ul><li>如果是基本类型与函数直接返回, 函数就不会丢失也不会拷贝</li> <li>如果是对象/数组创建拷贝对象/数组</li> <li>问题: 循环引用会出错的问题(死循环)</li></ul></li> <li>使用 Map 缓存拷贝对象
<ul><li>如果发现一个对象已经产生拷贝对象, 直接返回这人拷贝对象</li> <li>使用 Map 存储 ==&gt; key 为源对象, value 是拷贝产生的对象 (不能用对象来存储, 因为对象的 key 为字符串)</li></ul></li> <li>数组和对象用不同的遍历方式
<ul><li>如果是对象使用 for...in 遍历内部数据</li> <li>如果是数组使用 for/forEach 遍历内部数据</li></ul></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/*
1). 大众乞丐版
    问题1: 函数属性会丢失   原因: json字符串数据是不存在函数, 函数属性就会丢失
    问题2: 循环引用会出错   原因: 转换为json字符串是会产生死循环查找, 报错
利用JSON转换成json字符串, 再解析回来
*/</span>
<span class="token function">deepClone1</span> <span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">!==</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> target<span class="token operator">===</span><span class="token string">'object'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">/*
2). 面试基础版本
    解决问题1: 函数属性还没丢失
    问题2: 循环引用会出错  没有解决: 它会同个对象或数据进行不断拷贝
*/</span>
<span class="token function">deepClone2</span> <span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">!==</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> target<span class="token operator">===</span><span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 非函数的对象</span>
    <span class="token comment">// 创建一个新的空容器</span>
    <span class="token keyword">const</span> clone <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// 遍历target中所有数据, 依次添加到新容器</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// key是对象的属性名或数组的下标</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是容器自身的才需要处理</span>
        clone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> aUtils<span class="token punctuation">.</span><span class="token function">deepClone2</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 对属性值进行克隆处理后保存</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> clone
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/*
3). 面试加强版本
  解决问题2: 循环引用正常

  缓存的容器
    问题1: 什么结构的?  Map, key为target, value是对应的拷贝对象
    问题2: 保存什么数据  key是target, value是target对应的拷贝对象
  注意: 在整个递归调用过程中, 只有一个map在反复使用
*/</span>

<span class="token function">deepClone3</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">!==</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> target<span class="token operator">===</span><span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 非函数的对象</span>
   <span class="token comment">// const map = new Map()  // 用来缓存target与其对应的拷贝对象的容器   // 不能在这里</span>
    <span class="token comment">// 从缓存中取出对应的拷贝对象,如果有了, 直接返回它</span>
    <span class="token keyword">let</span> clone <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone<span class="token punctuation">)</span> <span class="token keyword">return</span> clone

    <span class="token comment">// 如果没有, 创建一个新拷贝空容器, 缓存起来</span>
    clone <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> clone<span class="token punctuation">)</span>

    <span class="token comment">// 遍历target中所有数据, 依次添加到新容器</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// key是对象的属性名或数组的下标</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是容器自身的才需要处理</span>
        clone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> aUtils<span class="token punctuation">.</span><span class="token function">deepClone3</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span> <span class="token comment">// 对属性值进行克隆处理后保存</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> clone
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/*
4). 面试加强版本2(优化遍历性能)
    数组: while | for | forEach() 优于 for-in | keys()&amp;forEach()
    对象: for-in 与 keys()&amp;forEach() 差不多
*/</span>
<span class="token function">deepClone4</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">!==</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> target<span class="token operator">===</span><span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 非函数的对象</span>
   <span class="token comment">// const map = new Map()  // 用来缓存target与其对应的拷贝对象的容器   // 不能在这里</span>
    <span class="token comment">// 从缓存中取出对应的拷贝对象,如果有了, 直接返回它</span>
    <span class="token keyword">let</span> clone <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone<span class="token punctuation">)</span> <span class="token keyword">return</span> clone

    <span class="token comment">// 如果没有, 创建一个新拷贝空容器, 缓存起来</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      clone <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
      map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> clone<span class="token punctuation">)</span>
      <span class="token comment">// 遍历target数组中所有元素, 依次添加到新容器</span>
      target<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// clone.push(aUtils.deepClone4(item, map))</span>
        clone<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> aUtils<span class="token punctuation">.</span><span class="token function">deepClone4</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> map<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      clone <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> clone<span class="token punctuation">)</span>
      <span class="token comment">// 遍历target对象中所有数据, 依次添加到新容器</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// key是对象的属性名或数组的下标</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是容器自身的才需要处理</span>
          clone<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> aUtils<span class="token punctuation">.</span><span class="token function">deepClone4</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span> <span class="token comment">// 对属性值进行克隆处理后保存</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> clone
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h3 id="数组相关"><a href="#数组相关" class="header-anchor">#</a> 数组相关</h3> <h4 id="数组扁平化"><a href="#数组扁平化" class="header-anchor">#</a> 数组扁平化</h4> <ol><li><p>使用数组原型中的 falt 方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>如果都是数字，可再进行遍历讲字符串转为数字</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>三点运算符</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ol> <h4 id="数组去重"><a href="#数组去重" class="header-anchor">#</a> 数组去重</h4> <ol><li><p>双重循环</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//外部循环取数</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> newArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//内层循环是为了和外层取的数取对比，看看新数组当中有没有</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> newArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newArr<span class="token punctuation">[</span>newArr<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li> <li><p>indexOf</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">removeRepeat</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> current <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>filter</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">removeRepeat</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> res <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>Object 键值对</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">removeRepeat</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> item <span class="token operator">+</span> item<span class="token punctuation">)</span>
      <span class="token operator">?</span> <span class="token boolean">false</span>
      <span class="token operator">:</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span><span class="token keyword">typeof</span> item <span class="token operator">+</span> item<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为1 和 '1' 是不同的，所以使用typeof item + item 拼成字符串作为 key 值</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>set 方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">removeRepeat</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ol> <h4 id="数组翻转"><a href="#数组翻转" class="header-anchor">#</a> 数组翻转</h4> <ol><li><p>使用原型中的 reverse 方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
array<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>循环</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <h4 id="排序算法"><a href="#排序算法" class="header-anchor">#</a> 排序算法</h4> <h5 id="简单排序-冒泡-选择-插入"><a href="#简单排序-冒泡-选择-插入" class="header-anchor">#</a> 简单排序: 冒泡 / 选择 / 插入</h5> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 
冒泡排序的方法
*/</span>
<span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1.获取数组的长度</span>
  <span class="token keyword">var</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

  <span class="token comment">// 2.反向循环, 因此次数越来越少</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 3.根据i的次数, 比较循环到i位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 4.如果j位置比j+1位置的数据大, 那么就交换</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 交换</span>
        <span class="token comment">// const temp = array[j+1]</span>
        <span class="token comment">// array[j+1] = array[j]</span>
        <span class="token comment">// array[j] = temp</span>
        <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 
选择排序的方法
*/</span>
<span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1.获取数组的长度</span>
  <span class="token keyword">var</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

  <span class="token comment">// 2.外层循环: 从0位置开始取出数据, 直到length-2位置</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 3.内层循环: 从i+1位置开始, 和后面的内容比较</span>
    <span class="token keyword">var</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 4.如果i位置的数据大于j位置的数据, 记录最小的位置</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        min <span class="token operator">=</span> j<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">!==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 交换</span>
      <span class="token punctuation">[</span>array<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 
插入排序的方法
*/</span>
<span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1.获取数组的长度</span>
  <span class="token keyword">var</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

  <span class="token comment">// 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 3.记录选出的元素, 放在变量temp中</span>
    <span class="token keyword">var</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">var</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      j<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 5.将选出的j位置, 放入temp元素</span>
    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> array<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br></div></div><h5 id="快速排序-选择性"><a href="#快速排序-选择性" class="header-anchor">#</a> 快速排序(选择性)</h5> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归结束的条件</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取中间值</span>
  <span class="token keyword">let</span> flag <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> flagValue <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> leftArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> rightArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> arrItem <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>arrItem <span class="token operator">&gt;</span> flagValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      rightArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arrItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      leftArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arrItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  leftArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>leftArr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  rightArr <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>rightArr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>leftArr<span class="token punctuation">,</span> flagValue<span class="token punctuation">,</span> <span class="token operator">...</span>rightArr<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="函数相关"><a href="#函数相关" class="header-anchor">#</a> 函数相关</h3> <h4 id="函数的-call-apply-bind"><a href="#函数的-call-apply-bind" class="header-anchor">#</a> 函数的 call() / apply() / bind()</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 
自定义函数对象的call方法
*/</span>
<span class="token keyword">function</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果传入的是null/undefined, this指定为window</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj <span class="token operator">=</span> obj <span class="token operator">||</span> window<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span>
  obj<span class="token punctuation">.</span>tempFn <span class="token operator">=</span> fn<span class="token punctuation">;</span>
  <span class="token comment">// 通过obj调用这个方法</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">tempFn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 删除新添加的方法</span>
  <span class="token keyword">delete</span> obj<span class="token punctuation">.</span>tempFn<span class="token punctuation">;</span>
  <span class="token comment">// 返回函数调用的结果</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 
自定义函数对象的apply方法
*/</span>
<span class="token keyword">function</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果传入的是null/undefined, this指定为window</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj <span class="token operator">=</span> obj <span class="token operator">||</span> window<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象</span>
  obj<span class="token punctuation">.</span>tempFn <span class="token operator">=</span> fn<span class="token punctuation">;</span>
  <span class="token comment">// 通过obj调用这个方法</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">tempFn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 删除新添加的方法</span>
  <span class="token keyword">delete</span> obj<span class="token punctuation">.</span>tempFn<span class="token punctuation">;</span>
  <span class="token comment">// 返回函数调用的结果</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 
  自定义函数对象的bind方法
  重要技术:
    高阶函数
    闭包
    call()
    三点运算符
*/</span>
<span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj <span class="token operator">=</span> obj <span class="token operator">||</span> window<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">call</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>args2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><h4 id="函数的节流-throttle-与防抖-debounce"><a href="#函数的节流-throttle-与防抖-debounce" class="header-anchor">#</a> 函数的节流(throttle)与防抖(debounce)</h4> <p>注意: 需要能区别节流与防抖</p> <ul><li>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发 scroll 事件时，并不执行 handle 函数，当 1000 毫秒内没有触发 scroll 事件时，才会延时触发 scroll 事件。
<img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144209623-862434090.jpg" alt="防抖"></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/*
实现函数节流的函数
*/</span>

<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 必须保存第一次点击立即调用</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 事件回调函数</span>
    <span class="token comment">// this 是发生事件的 dom 元素</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;throttle 事件&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> current <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">-</span> start <span class="token operator">&gt;</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 从第 2 次点击开始, 需要间隔时间超过 delay</span>
      <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 将当前时间指定为 start, ==&gt; 为后面的比较做准备</span>
      start <span class="token operator">=</span> current<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ul><li>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发 scroll 事件时，并不立即执行 handle 函数，每隔 1000 毫秒才会执行一次 handle 函数。
<img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144342847-660853255.jpg" alt="节流"></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/*
实现函数防抖的函数
*/</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;debounce 事件...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 清除待执行的定时器任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback<span class="token punctuation">.</span>timeoutId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">.</span>timeoutId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 每隔delay的时间, 启动一个新的延迟定时器, 去准备调用callback</span>
    callback<span class="token punctuation">.</span>timeoutId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 如果定时器回调执行了, 删除标记</span>
      <span class="token keyword">delete</span> callback<span class="token punctuation">.</span>timeoutId<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="字符串处理"><a href="#字符串处理" class="header-anchor">#</a> 字符串处理</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/</span>

<span class="token comment">/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
*/</span>
<span class="token keyword">function</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// return str.split('').reverse().join('')</span>
  <span class="token comment">// return [...str].reverse().join('')</span>
  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
*/</span>
<span class="token keyword">function</span> <span class="token function">palindrome</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> str <span class="token operator">===</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/</span>
<span class="token keyword">function</span> <span class="token function">truncate</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> str<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> num <span class="token operator">?</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;...&quot;</span> <span class="token operator">:</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h2 id="git-操作"><a href="#git-操作" class="header-anchor">#</a> git 操作</h2> <ul><li><p>git config --global credential.helper store (记住用户和密码)</p></li> <li><p>分支操作</p> <p>​ 拉取远程新分支到本地</p> <p>​ git pull (如果分支是在 clone 后创建的才需要执行)</p> <p>​ git checkout -b dev origin/dev</p></li> <li><p>版本注释一般规范
feat 特性：新增功能</p> <p>docs 文档：新增文档</p> <p>fix 修复 Bug</p></li> <li><p>xiongjian 分支到本地仓库 xiongjian 分支上</p> <p>git fetch origin xiongjian:xiongjian 拉取远程仓库</p></li></ul> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h2> <h3 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h3> <ul><li><p>entry 入口</p> <p>指示 webpack 从哪个文件开始打包</p></li> <li><p>output 输出</p> <p>指示 webpack 将打包后的文件输出到哪里去</p></li> <li><p>loader 加载器</p> <p>帮助 webpack 解析它解析不了的模块（将其他模块解析成 webpack 能识别的模块，这样才能打包）</p> <p>还有其他功能：多进程打包...</p></li> <li><p>plugin 插件</p> <p>能够功能更加强大的事</p> <p>将现有库包装成 webpack 能够识别的功能模块，从而加载使用</p></li> <li><p>mode 模式</p> <p>模式（development/production）</p> <p>区别：设置不同 NODE_ENV，启用不同的插件</p></li></ul> <h3 id="其他配置"><a href="#其他配置" class="header-anchor">#</a> 其他配置</h3> <ul><li><p>resolve 解析：帮助 webpack 解析模块</p> <p>alias 配置路径别名</p> <p>extensions 配置自动补全文件扩展名</p> <p>modules 配置 引入 node_modules 库，node_modules 文件夹去哪找</p></li> <li><p>optimization 优化</p></li> <li><p>devServer 开发服务器</p></li></ul> <h3 id="兼容性处理"><a href="#兼容性处理" class="header-anchor">#</a> 兼容性处理</h3> <ul><li>JS 兼容性处理 babel</li> <li>CSS 兼容性处理，使用 postcss-loader 做 css 兼容性处理</li></ul> <h3 id="摇树（tree-shaking）"><a href="#摇树（tree-shaking）" class="header-anchor">#</a> 摇树（<strong>tree shaking</strong>）</h3> <ul><li><p>摇树：去除无用的 JS 代码</p></li> <li><p>配置</p> <p>必须使用 ES6 模块化</p> <p>开启 mode: production</p></li></ul> <h3 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h3> <ul><li><p>客户端端缓存服务器请求的资源（js/css/图片...）</p> <ul><li><p>强制缓存（不会重新访问服务器，直接读取缓存）</p> <p>问题：如果资源在缓存期间内，是没办法更新的~</p></li> <li><p>协商缓存（每次都会重新访问服务器，由服务器来决定要不要走缓存，304）</p></li></ul></li> <li><p>hash webpack 打包生成的，所以资源共享 hash 值</p> <p>问题：如果改动一个资源，所有资源的 hash 都变~导致其他资源缓存失效</p></li> <li><p>chunkhash 属于同一个 chunk，hash 值一样，不同 chunk，hash 值不一样</p> <p>问题：单入口样式文件因为 css-loader，会把样式文件打包到 js 中，此时就会和 js 共享同一个 hash 值，一旦改动 js/css 文件，css/js 文件缓存失效</p></li> <li><p>contenthash 根据文件内容来生成 hash，不同文件 hash 值不同</p> <p>新问题：如果 A 文件采用 import 进行代码分割文件 B，分割文件 B 一旦变化，那么 A 文件缓存失效</p> <p>原因是：A 文件保存 B 文件的 hash 值，一旦 B 文件变化，A 文件的 hash 值也要更新，从而导致 A 文件也变了</p> <p>解决：需要将 A 文件保存 B 文件的 hash 值单独提取出来，成单独文件，这样就不会影响 A 文件了</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>runtimeChunk<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">name</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">entry</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">runtime-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>entry<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.js</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <h3 id="关闭-map-vue-项目生产环境"><a href="#关闭-map-vue-项目生产环境" class="header-anchor">#</a> 关闭 map(vue 项目生产环境)</h3> <p>productionSourceMap: false, // 关闭 map 映射文件</p> <h2 id="vue-基础"><a href="#vue-基础" class="header-anchor">#</a> Vue 基础</h2> <h3 id="组件间通信的方式"><a href="#组件间通信的方式" class="header-anchor">#</a> 组件间通信的方式</h3> <h4 id="根据通信的-2-个组件间的关系来选择一种通信方式"><a href="#根据通信的-2-个组件间的关系来选择一种通信方式" class="header-anchor">#</a> 根据通信的 2 个组件间的关系来选择一种通信方式</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>父子
	props
	vue自定义事件
	v-model
	.sync
	$ref, $children与$parent
	插槽 ==&gt; 作用域插槽
祖孙
	$attrs与$listeners
	provide与inject
兄弟或其它/任意
	全局事件总线
	Vuex
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="方式-1-props"><a href="#方式-1-props" class="header-anchor">#</a> 方式 1: props</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>1). 实现父向子通信: 属性值是非函数
2). 实现子向父通信: 属性值是函数
应用: 最基本, 用得最多的方式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="方式-2-vue-自定义事件"><a href="#方式-2-vue-自定义事件" class="header-anchor">#</a> 方式 2: vue 自定义事件</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>1). 用来实现子组件向父组件通信
2). 相关语法:
    父组件中绑定自定义事件监听:
      &lt;Child @eventName=&quot;callback&quot;&gt;
    子组件中分发事件
      this.$emit('eventName', data)
应用: elment-ui的组件的事件监听语法都用的是自定义事件
      我们项目中的组件也用了不少自定义事件
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="方式-3-全局事件总线-消息订阅与发布"><a href="#方式-3-全局事件总线-消息订阅与发布" class="header-anchor">#</a> 方式 3: 全局事件总线 ===&gt; 消息订阅与发布</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>1). 实现任意组件间通信
2). 编码:
    将入口js中的vm作为全局事件总线对象:
        beforeCreate() {
            Vue.prototype.$bus = this
        }
    分发事件/传递数据的组件: this.$bus.$emit('eventName', data)
    处理事件/接收数据的组件: this.$bus.$on('eventName', (data) =&gt; {})
应用: 前台项目中使用全局事件总线
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="方式-4-v-model"><a href="#方式-4-v-model" class="header-anchor">#</a> 方式 4: v-model</h4> <div class="language- extra-class"><pre><code>1). 实现父子之间相互通信/同步
2). 组件标签上的v-model的本质: 动态value属性与自定义input监听来接收子组件分发的数据更新父组件数据
    父组件:
        &lt;CustomInput v-model=&quot;name&quot;/&gt;
        &lt;!-- 等价于 --&gt;
        &lt;CustomInput :value=&quot;name&quot; @input=&quot;name=$event&quot;/&gt;
    子组件:
        &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;$emit('input', $event.target.value)&quot;&gt;
        props: ['value']
应用: element-ui中的表单项相关组件都用了v-model: Input / Select / Checkbox / Radio
</code></pre></div><h4 id="方式-5-sync"><a href="#方式-5-sync" class="header-anchor">#</a> 方式 5: .sync</h4> <div class="language- extra-class"><pre><code>1). 实现父子之间相互通信/同步(在原本父向子的基础上增加子向父)
2). 组件标签的属性上使用.sync的本质: 通过事件监听来接收子组件分发过来的数据并更新父组件的数据
    父组件:
        &lt;child :money.sync=&quot;total&quot;/&gt;
        &lt;!-- 等价于 --&gt;
        &lt;Child :money=&quot;total&quot; @update:money=&quot;total=$event&quot;/&gt;

        data () {
          return {
            total: 1000
          }
        },
    子组件:
        &lt;button @click=&quot;$emit('update:money', money-100)&quot;&gt;花钱&lt;/button&gt;
        props: ['money']
应用:
    element-ui在有显示隐藏的组件上: Dialog / Drawer
</code></pre></div><h4 id="方式-6-attrs与-listeners"><a href="#方式-6-attrs与-listeners" class="header-anchor">#</a> 方式 6: $attrs与$listeners</h4> <div class="language- extra-class"><pre><code>1). $attrs
    实现当前组件的父组件向当前组件的子组件通信
    它是包含所有父组件传入的标签属性(排除props声明, class与style的属性)的对象
    使用: 通过 v-bind=&quot;$attrs&quot; 将父组件传入的n个属性数据传递给当前组件的子组件
2). $listeners
    实现当前组件的子组件向当前组件的父组件通信
    $listeners是包含所有父组件传入的自定义事件监听名与对应回调函数的对象
    使用: 通过v-on=&quot;$listeners&quot; 将父组件绑定给当前组件的事件监听绑定给当前组件的子组件
应用: 利用它封装了一个自定义的带hover文本提示的el-button
</code></pre></div><h4 id="方式-7-refs-children-parent"><a href="#方式-7-refs-children-parent" class="header-anchor">#</a> 方式 7: $refs &amp; $children &amp; $parent</h4> <div class="language- extra-class"><pre><code>1). $refs
    实现父组件向指定子组件通信
    $refs是包含所有有ref属性的标签对象或组件对象的容器对象
    使用: 通过 this.$refs.child 得到子组件对象, 从而可以直接更新其数据或调用其方法更新数据
2). $children
    实现父组件向多个子组件通信
    $children是所有直接子组件对象的数组
    使用: 通过this.$children 遍历子组件对象, 从而可以更新多个子组件的数据
3). $parent
    实现子组件向父组件通信
    $parent是当前组件的父组件对象
    使用: 通过this.$parent 得到父组件对象, 从而可以更新父组件的数据
应用: 在后台管理项目中使用了$refs
</code></pre></div><h4 id="方式-8-provide-与-inject"><a href="#方式-8-provide-与-inject" class="header-anchor">#</a> 方式 8: provide 与 inject</h4> <div class="language- extra-class"><pre><code>1). 实现祖孙组件间直接通信
2). 使用
	在祖组件中通过provide配置向后代组件提供数据
	在后代组件中通过inject配置来声明接收数据
3). 注意:
	不太建议在应用开发中使用, 一般用来封装vue插件
	provide提供的数据本身不是响应式的 ==&gt; 父组件更新了数据, 后代组件不会变化
	provide提供的数据对象内部是响应式的 ==&gt; 父组件更新了数据, 后代组件也会变化
应用: element-ui中的Form组件中使用了provide和inject
</code></pre></div><h4 id="方式-9-vuex"><a href="#方式-9-vuex" class="header-anchor">#</a> 方式 9: vuex</h4> <ul><li><p>vuex 用来统一管理多个组件共享的状态数据</p></li> <li><p>任意要进行通信的 2 个组件利用 vuex 就可以实现</p> <p>A 组件触发 action 或 mutation 调用, 将数据保存到 vuex 的状态中</p> <p>B 组件读取 vuex 中的 state 或 getters 数据, 得到最新保存的数据进行显示</p></li> <li><p>面试题</p> <ol><li><p>mutation 负责同步修改状态数据的，能不能异步修改</p> <p>可以异步修改</p> <p>如果异步修改的话会导致 Vuex 的调试工具失效，无法检测异步修改数据</p></li> <li><p>设计的时候为什么建议 mutation 同步修改状态数据，而新增 action 负责异步</p> <p>Vuex 的作用是给多个组件共享数据</p> <p>如果支持 mutation 异步修改数据，又因为异步的特性，会导致 store 对象中 state 数据发生错乱甚至是报错</p> <p>为了数据的安全</p></li> <li><p>Vuex 刷新页面，数据丢失问题</p> <p>方案一：Vuex 的数据都是每次组件加载时候动态请求获取数据保存(性能差，因为网络问题可能有网络延迟)</p> <p>方案二：将 Vuex 中的数据每次同步更新保存到 sessionStorage 中( state 中的数据是动态的，就需要一直要同步到 sessionStorage 中，性能差)</p> <p>方案三：在页面刷新之前获取 Vuex 的数据，将数据保存在 sessionStorage 中，页面加载后从 sessionStorage 中获取</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// beforeunload 页面即将刷新之前调用</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;beforeunload&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&quot;test2&quot;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>personArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 读取sessionStorage中是否有之前缓存的数据</span>
<span class="token keyword">let</span> personArr <span class="token operator">=</span> sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;test2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果有： 更新Vuex中状态数据</span>
personArr <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">changePersonArrMutation</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>personArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li></ol></li></ul> <h4 id="方式-10-插槽-作用域插槽-slot-scope"><a href="#方式-10-插槽-作用域插槽-slot-scope" class="header-anchor">#</a> 方式 10: 插槽 ==&gt; 作用域插槽 slot-scope</h4> <ol><li><p>实现父组件向子组件传递标签内容</p></li> <li><p>什么情况下使用作用域插槽?
父组件需要向子组件传递标签结构内容
但决定父组件传递怎样标签结构的数据在子组件中</p></li> <li><p>编码:
子组件:</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- slot的属性会自动传递给父组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">:row</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:$index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>index<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
父组件:
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{row, $index}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{$index+1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> <span class="token entity named-entity" title="&amp;nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&amp;nbsp;">&amp;nbsp;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{color: $index%2===1 ? <span class="token punctuation">'</span>blue<span class="token punctuation">'</span> : <span class="token punctuation">'</span>green<span class="token punctuation">'</span>}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{row.text}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>应用: element-ui 中的 Table 组件</p></li></ol> <h3 id="computed-与-method-和-watch-的区别"><a href="#computed-与-method-和-watch-的区别" class="header-anchor">#</a> computed 与 method 和 watch 的区别</h3> <ul><li><p><strong>computed</strong></p> <ol><li>支持缓存，多次读取, 只会执行一次计算, 只有依赖数据发生改变，才会重新进行计算</li></ol></li></ul> <ol start="2"><li>不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化</li> <li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值</li> <li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed</li> <li>如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当计算属性数据变化时，调用 set 方法。</li></ol> <ul><li><p>method</p> <ul><li>没有缓存, 多次读取, 必须多次调用</li></ul></li> <li><p><strong>watch</strong></p> <ol start="2"><li><p>watch 支持异步；</p></li> <li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p></li> <li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p></li> <li><p>监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数，</p></li></ol> <p>immediate：组件加载立即触发回调函数执行，</p> <p>deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变</p></li></ul> <h3 id="如何理解-vue-的渐进式"><a href="#如何理解-vue-的渐进式" class="header-anchor">#</a> 如何理解 vue 的渐进式</h3> <p><img src="https://img-blog.csdn.net/201806191038393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6dW5rdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="渐进式"></p> <ul><li>vue 的核心就是声明式渲染, 在前台动态显示界面</li> <li>在此基础上就是其组件系统, 我们来实现组件化编程</li> <li>vue 本身并没有做路由, 大规模状态管理, 请求等实现, 在编写应用中可以根据需要加入相应的插件来实现</li> <li>最后对项目进行打包运行</li></ul> <h3 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 注册一个全局自定义指令 `v-focus`</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">&quot;focus&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当被绑定的元素插入到 DOM 中时……</span>
  <span class="token function-variable function">inserted</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 聚焦元素</span>
    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="vuex-和-redux-的区别"><a href="#vuex-和-redux-的区别" class="header-anchor">#</a> vuex 和 redux 的区别</h3> <ul><li>vuex:
<ul><li>我们直接在 mutation 中直接更新状态数据</li> <li>直接可以在 action 中执行异步操作</li></ul></li> <li>redux:
<ul><li>只能通过 reducer 返回一个新的状态数据, 由 redux 内部自己更新</li> <li>本身不支持异步, 必须引入 react-redux 之类的插件才支持异步</li></ul></li></ul> <h3 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h3> <ul><li><p>M --&gt; Model 数据层（为模板页面提供数据 data）</p></li> <li><p>V --&gt; View 视图层（模板页面）</p></li> <li><p>VM --&gt; ViewModel 通过数据绑定和 DOM 事件监听来实现 Model 和 View 的双向数据绑定</p></li></ul> <p>​ 数据绑定： Model --&gt; View</p> <p>​ DOM 事件监听: View --&gt; Model</p> <h3 id="vue-数据流"><a href="#vue-数据流" class="header-anchor">#</a> Vue 数据流</h3> <ol><li>Vue 也是一个单向数据流的框架</li> <li>Vue 通过指令实现了双向数据绑定： v-model</li> <li>v-model 都做了哪些事情; <input> <ol><li>将指定变量的数据赋值给 input 的 value</li> <li>给当前的表单相自动绑定一个 input 事件，监听 View 层表单项数据发生改变获取最新 value 的同时更新 Model 的数据</li></ol></li></ol> <h3 id="数据劫持-数据绑定"><a href="#数据劫持-数据绑定" class="header-anchor">#</a> 数据劫持-数据绑定</h3> <p>流程：new MVVM()</p> <ol><li>数据代理 (_proxyData)</li></ol> <p>​ 将 data 数据代理到 vm 上，并定义属性 getter 和 setter</p> <p>​ 当调用 getter 时，内部实际上是读取原属性的值 vm._data[key]</p> <p>​ 当调用 setter 时，内部实际上是设置原属性的值 vm._data[key] = val;</p> <ol start="2"><li>将 data 数据变成响应式数据 (observer)</li></ol> <p>​ 递归遍历原 data 所有数据（不是 vm 上的数据/不是代理数据）重新定义属性的 getter 和 setter</p> <p>​ 将其定义成响应式数据</p> <p>​ 同时每一个响应式属性都会有对应一个唯一的 dep，这个 dep 通过闭包的方式保存在 getter 和 setter 中</p> <p>​ getter</p> <p>​ 建立 dep 和 watcher 的联系</p> <p>​ 在 dep 中通过 subs 保存多个 watcher</p> <p>​ 在 watcher 中通过 depIds 保存多个 dep</p> <p>​ setter</p> <p>​ dep.notify() 通知当前 dep 中所有 watcher 去更新用户界面</p> <ol start="3"><li>模板编译</li></ol> <p>​ 1) 将 el 所有元素子节点添加到 fragment 文档碎片节点中</p> <p>​ 2) 编译 fragment 节点中模板语法</p> <p>​ 递归遍历 fragment 所有字节点</p> <p>​ 判断子节点元素类型 nodeType</p> <p>​ 如果是元素节点 nodeType === 1</p> <p>​ 获取元素所有属性，判断属性里面是否包含指令属性 v-</p> <p>​ 事件指令属性 on</p> <p>​ node.addEventListener(eventType, cb.bind(vm), false)</p> <p>​ 普通指令属性</p> <p>​ 根据指令类型来执行不同的 updater 方法更新用户界面</p> <p>​ 同时会创建一个 watcher（此时会读取 vm 属性，最终会触发 getter 从而建立 dep 和 watcher 之间的联系）</p> <p>​ 解析完指令属性后，最终移除元素上的指令语法属性</p> <p>​ 如果是文本节点并且包含插值语法 nodeType === 3</p> <p>​ 直接调用 textUpdater 更新用户界面</p> <p>​ 同时会创建一个 watcher（此时会读取 vm 属性，最终会触发 getter 从而建立 dep 和 watcher 之间的联系）</p> <p>​ 3) 将编译好的 fragment 插入到 el 中生效</p> <p>​ 最后当用户更新 data 数据时， this.name = 'rose'</p> <p>​ 触发 name 的 setter 方法</p> <p>​ 调用 dep.notify() 通知当前 dep 中所有 watcher 去更新用户界面</p> <p>​ 从而用户界面发生变化</p> <p>​ 总结：当数据更新时，即更新数据也更新用户界面。这样的数据就是响应式数据</p> <h3 id="vue-实例的生命周期函数"><a href="#vue-实例的生命周期函数" class="header-anchor">#</a> Vue 实例的生命周期函数</h3> <ol><li>初始化渲染阶段（new Vue()产生，只会执行 1 次）</li></ol> <ul><li><p><strong>beforeCreate()</strong></p> <p>在实现数据代理和监听之前调用的</p> <p>所以：不能访问 data/methods 数据，不能创建 vm 之前触发的，此时已经创建了 vm</p></li> <li><p><strong>面试题 1</strong>： 在 beforeCreate 中如何获取 data 中的数据值</p> <p><code>this.$options.data().msg</code></p></li> <li><p><strong>created()</strong></p> <p>在实现数据代理和监听之后调用的</p> <p>可以访问所有数据</p></li> <li><p><strong>beforeMount()</strong></p> <p>在页面挂载（渲染）之前触发</p></li> <li><p><strong>mounted()</strong></p> <p>在页面挂载（渲染）之后触发</p> <p>$el：element $el 代表将虚拟 DOM 对象编译后的真实 DOM 对象片段,在 mounted 可见</p></li></ul> <ol start="2"><li>更新状态（当 data 数据发生变化，就会自动更新, 触发 n 次）</li></ol> <ul><li><p><strong>beforeUpdate()</strong></p> <p>在更新之前触发</p> <p>此时 data 数据已经更新完毕，但是页面没有更新</p></li> <li><p><strong>updated()</strong></p> <p>在更新之后触发</p> <p>data 数据更新完毕，页面也更新完毕</p></li></ul> <ol start="3"><li><p>销毁/死亡阶段( this/vm.$destroy()触发，触发 1 次 )</p> <p>页面的动态数据在 Vue 组件<strong>实例</strong>销毁的一瞬间使用其最后的数据</p> <p>静态页面还在</p></li></ol> <ul><li><p><strong>beforeDestory()</strong></p> <p>在销毁之前调用</p></li> <li><p><strong>destoryed()</strong></p> <p>在销毁之后调用</p></li></ul> <h4 id="重要生命周期函数（开发中常用）"><a href="#重要生命周期函数（开发中常用）" class="header-anchor">#</a> 重要生命周期函数（开发中常用）</h4> <ul><li><p><strong>created / mounted</strong></p> <p>发送 AJAX 请求、设置定时器等一次性任务</p> <p>created 速度更快</p></li> <li><p><strong>beforeDestroy</strong></p> <p>做一些收尾工作：取消 AJAX 请求，清除定时器等</p></li></ul> <h4 id="周期函数补充"><a href="#周期函数补充" class="header-anchor">#</a> 周期函数补充</h4> <ul><li><p>动态组件</p> <p><code>&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;</code> is 属性来切换不同的组件</p> <p>正常传入 props 数据就可以接受到</p></li> <li><p>缓存组件</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">:include</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>[<span class="token punctuation">'</span>a<span class="token punctuation">'</span>,<span class="token punctuation">'</span>b<span class="token punctuation">'</span>]&gt;
  &lt;component :is=<span class="token punctuation">&quot;</span></span><span class="token attr-name">view&quot;</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><strong>errorCaptured(errObj, errVM, errMsg)</strong></p> <p>捕获一个来自子孙组件的错误时被调用</p> <p>return false // 阻止错误继续向上传播，并且不会在浏览器控制台抛出错误</p> <p>参数：错误对象，抛出错误的实例，错误信息</p></li></ul> <h5 id="在缓存组件的基础上存在的声明周期"><a href="#在缓存组件的基础上存在的声明周期" class="header-anchor">#</a> 在缓存组件的基础上存在的声明周期</h5> <ul><li><p><strong>activated()</strong></p> <p>每次缓存组件被激活时就会调用</p></li> <li><p><strong>deactivated()</strong></p> <p>缓存的组件停用时调用，可替代 destroyed</p></li></ul> <h3 id="为什么组件中的-data-必须是函数形式？"><a href="#为什么组件中的-data-必须是函数形式？" class="header-anchor">#</a> 为什么组件中的 data 必须是函数形式？</h3> <ul><li>Vue 解析组件标签时，最会创建一个新的组件实例对象</li> <li>每个组件实例对象, 都需要有自己的 data 数据对象</li> <li>如果 data 配置是对象, 就会导致同个组件的多个实例共享一个 data 对象</li> <li>如果 data 是函数, 组件的多个实例的 data 对象是各自的, 是多份</li></ul> <h3 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h3> <ul><li><p>当从 C 组件切换到 C 组件（只更新参数的时候），C 组件并不会被重新创建或卸载，而是复用之前 C 组件，这样会导致只有路由变化，页面没有发生变化</p> <p><span style="color:red;">解决方案：</span></p> <p>​ 使用 watch 进行监视，因为每次更新时，$route 都会创建一个新对象 ，而不是原对象，所以所有数据都是新的，可以监视</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>watch<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">$route</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// to 变化前的路由对象</span>
    <span class="token comment">// from 变化后的路由对象</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p><strong>history 模式刷新 404 问题解决方法</strong></p> <p>通过配置 webpack 来解决：在 devServer 中加 historyApiFallback: true</p> <p>index.html 需要将 href=&quot;./bootstrap.css&quot; 改成 href=&quot;/bootstrap.css&quot;</p> <p>webpack.config.js 需要 output 上增加 publicPath: '/'</p></li> <li><p><strong>命名路由的时候 params 和 query 分别可以和什么搭配使用</strong></p> <p>query + name</p> <p>query + path</p> <p>params + name</p></li> <li><p><strong>路由传参</strong></p> <ol><li><p>query
传参方式：</p> <div class="language- extra-class"><pre><code>1. 注册的路由的时候不需要做任何事情
   2. 请求的时候通过path?key=value&amp;key2=value2
</code></pre></div><p>获取: $route.query.key</p> <p>使用场景：适合多个参数</p></li> <li><p>params</p> <p>传参方式:</p> <ol><li>注册路由的时候需要声明占位符，{path: '路由路径/:key(占位符)'}</li> <li>请求的时候通过 path/params 参数</li></ol> <p>获取: $route.params.key</p> <p>使用场景：</p> <ol><li>通常只有一个参数的时候(也可以指定多个 params 参数)</li> <li>该参数通常是一个标识 id</li></ol></li> <li><p>meta</p> <p>传参方式:</p> <ol><li>注册的时候通过 meta 字段进行参数设置</li></ol> <p>获取: $route.meta.key</p> <p>使用场景：</p> <ol><li>路由元信息，用于描述当前的路由信息</li> <li>可以自定义参数内容的时候(可以有多个)</li></ol></li> <li><p>props</p> <p>传参方式:</p> <ol><li>布尔值(只能搭配 params 参数使用)</li> <li>对象(用于自定义参数)</li> <li>函数(自定义参数 + 路由信息)</li></ol> <p>获取: 在组件内部通过 props 接收获取</p> <p>使用场景：用来解耦$route 和组件实例的耦合度</p></li></ol></li> <li><p><strong>params 传入多个参数行不行</strong></p> <p>可以，第一次加载没问题，刷新没有用冒号指定的参数消失</p> <p>只有在路由中指定的参数才可以正常使用</p></li> <li><p><strong>$router VS $route 的区别</strong></p> <ol><li><p>$router</p> <p>路由器对象</p> <p>用来控制路由的跳转，包含相关方法: push()/replace()/back()/addRoutes()</p></li> <li><p>$route</p> <p>路由信息对象</p> <p>包含当前路由的所有信息(path, query, params, meta)</p></li></ol></li></ul> <h3 id="导航守卫（路由守卫）"><a href="#导航守卫（路由守卫）" class="header-anchor">#</a> 导航守卫（路由守卫）</h3> <h4 id="全局前置守卫"><a href="#全局前置守卫" class="header-anchor">#</a> 全局前置守卫</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用场景： 验证用户身份，判断用户是否登录</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isLogin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果登录，正常跳转至home</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果未登录就跳转至登录界面</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">===</span> <span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="全局解析守卫"><a href="#全局解析守卫" class="header-anchor">#</a> 全局解析守卫</h4> <ul><li>这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 负责解析路由地址，加载对应的路由组件</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="全局后置钩子"><a href="#全局后置钩子" class="header-anchor">#</a> 全局后置钩子</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 路由完全跳转后执行</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="组件内的守卫"><a href="#组件内的守卫" class="header-anchor">#</a> 组件内的守卫</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在渲染该组件的对应路由被 confirm 前调用</span>
    <span class="token comment">// 不！能！获取组件实例 `this`</span>
    <span class="token comment">// 可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</span>
    <span class="token comment">// 因为当守卫执行前，组件实例还没被创建</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 通过 `vm` 访问组件实例</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在当前路由改变，但是该组件被复用时调用</span>
    <span class="token comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>
    <span class="token comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 导航离开该组件的对应路由时调用</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h3> <p>引入路由时，动态引入，代码分割，异步加载，例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;../components/Home/Home&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>import 函数不是 webpack 提供的语法。是 es6 语法</p> <h3 id="vue-use"><a href="#vue-use" class="header-anchor">#</a> Vue.use</h3> <ol><li><p>自定义 Vue 插件需要向外暴露对象或者是函数</p></li> <li><p>如果向外暴露对象的话，对象中必须有 install 方法</p></li> <li><p>如果向外暴露的是函数的话，那么该函数本身就是 install 方法</p></li> <li><p>当 Vue.use()的时候，会自动调用 install 方法，并且将 Vue 对象作为实参传入到 install 方法中</p></li></ol> <h3 id="打包相关"><a href="#打包相关" class="header-anchor">#</a> 打包相关</h3> <ul><li><p>关闭 map 文件映射配置</p> <p>productionSourceMap: false, // 关闭 map 映射文件</p></li></ul> <h2 id="vue-前台项目问题"><a href="#vue-前台项目问题" class="header-anchor">#</a> Vue 前台项目问题</h2> <h3 id="路由跳转与传参相关问题"><a href="#路由跳转与传参相关问题" class="header-anchor">#</a> 路由跳转与传参相关问题</h3> <p><strong>面试问题 1: 指定 params 参数时可不可以用 path 和 params 配置的组合?</strong></p> <p>​ 不可以用 path 和 params 配置的组合, 只能用 name 和 params 配置的组合</p> <p>​ query 配置可以与 path 或 name 进行组合使用</p> <p><strong>面试问题 2: 如何指定 params 参数可传可不传?</strong></p> <p>​ <code>path: '/search/:keyword?'</code></p> <p><strong>面试问题 3: 如果指定 name 与 params 配置, 但 params 中数据是一个&quot;&quot;, 无法跳转</strong></p> <p>​ 解决 1: 不指定 params</p> <p>​ 解决 2: 指定 params 参数值为 undefined</p> <p><strong>面试问题 4: 路由组件能不能传递 props 数据?</strong></p> <p>​ 可以: 可以将 query 或且 params 参数映射成 props 传递给路由组件对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//在routes中配置</span>
<span class="token function-variable function">props</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">route</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  keyword1<span class="token operator">:</span> route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>keyword<span class="token punctuation">,</span>
  keyword2<span class="token operator">:</span> route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>keyword<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>面试问题 5(非常重要): 编程式路由跳转到当前路由(参数不变), 会抛出 NavigationDuplicated 的警告错误</strong></p> <p>​ 面试问题: 在做项目时有没有遇到比较难的问题?(可做回答)</p> <p>回答步骤：</p> <ol><li><p><strong>我的问题</strong>: 我在上一个项目时没有问题, 后面再做一个新的项目时就有了问题</p></li> <li><p><strong>原因分析</strong>: vue-router3.1.0 之后, 引入了 push()的 promise 的语法, 如果没有通过参数指定回调函数就返回一个 promise 来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数都没有变化, 会抛出一个失败的 promise</p></li> <li><p><strong>解决办法</strong>:解决 1: 在跳转时指定成功或失败的回调函数, 通过 catch 处理错误</p> <p>​ 解决 2: 修正 Vue 原型上的 push 和 replace 方法 (优秀)</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 缓存原型上的push方法</span>
<span class="token keyword">const</span> originPush <span class="token operator">=</span> <span class="token class-name">VueRouter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push<span class="token punctuation">;</span>
<span class="token class-name">VueRouter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">push</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">location<span class="token punctuation">,</span> onComplete<span class="token punctuation">,</span> onAbort</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;push()&quot;</span><span class="token punctuation">,</span> location<span class="token punctuation">,</span> onComplete<span class="token punctuation">,</span> onAbort<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// this是路由器对象 $router</span>
  <span class="token comment">// 如果调用push, 传递了成功或者失败的回调函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>onComplete <span class="token operator">||</span> onAbort<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 让原来的push方法进行处理</span>
    <span class="token function">originPush</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> location<span class="token punctuation">,</span> onComplete<span class="token punctuation">,</span> onAbort<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不用返回, 因为执行的结果返回是undfined</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果调用push, 没传递了成功或者失败的回调函数, 可能会抛出失败的promise, 需要catch一下</span>
    <span class="token keyword">return</span> <span class="token function">originPush</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> location<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;catch error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 必须返回产生的promise对象</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></li></ol> <h2 id="解决在二层及以上的路由路径上刷新-丢失-reset-样式的问题"><a href="#解决在二层及以上的路由路径上刷新-丢失-reset-样式的问题" class="header-anchor">#</a> <strong>解决在二层及以上的路由路径上刷新, 丢失 reset 样式的问题</strong></h2> <ul><li><p>因为 history 模式的缘故</p> <p>页面中引入 reset: <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt;</code></p></li> <li><p>解决：</p> <p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/reset.css&quot;&gt;</code></p></li></ul> <h3 id="对-axios-进行二次封装（面试必说）"><a href="#对-axios-进行二次封装（面试必说）" class="header-anchor">#</a> 对 axios 进行二次封装（面试必说）</h3> <ol><li><p>配置通用的基础路径和超时:</p> <p>​ axios.create({baseURL, timeout})</p></li> <li><p>显示请求进度条</p> <p>​ 显示: 准备发请求前显示, 在请求拦截器中执行 NProgress.start()</p> <p>​ 隐藏: 请求结束隐藏, 在响应拦截器成功/失败回调中 NProgress.done()</p></li> <li><p>携带 token 数据</p> <p>​ 在请求拦截器中, 将 token 添加到请求头中</p></li> <li><p>成功返回的数据不再是 response, 而直接是响应体数据 response.data</p> <p>​ 响应拦截器成功的回调中: return response.data</p></li> <li><p>统一处理请求错误, 具体请求也可以选择处理或不处理</p> <p>​ 在响应拦截器失败的回调中: alert 提示错误信息, return Promise.reject(error)</p></li></ol> <h3 id="测试调用接口请求函数（跨域问题）"><a href="#测试调用接口请求函数（跨域问题）" class="header-anchor">#</a> 测试调用接口请求函数（跨域问题）</h3> <ol><li><p>出 404 的错误</p> <p>​ axios 请求配置的地址: /api/product/getBaseCategoryList'</p> <p>​ 当前发请求所在的地址:　http://localhost:8080/</p> <p>​ 最终 ajax 请求的地址: http://localhost:8080/api/product/getBaseCategoryList (没人处理)</p></li> <li><p>解决办法 1</p> <p>​ 配置 baseURL: http://182.92.128.115/api ==&gt; 成功的前提是后台允许 ajax 跨域</p></li> <li><p>使用代理服务器转发到目标接口地址 (使用代理解决 ajax 跨域)</p> <p>​ 配置 baseURL: /api</p> <p>​ 配置代理: vue.config.js 中</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
  proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 配置代理</span>
    <span class="token string">&quot;/api&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 只处理以/api开头的请求</span>
      target<span class="token operator">:</span> <span class="token string">&quot;http://182.92.128.115&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 转发的目标地址</span>
      changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 支持跨域</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ol> <h4 id="vuex-的基本使用"><a href="#vuex-的基本使用" class="header-anchor">#</a> vuex 的基本使用</h4> <ul><li>store 对象: state, mutations, actions, getters 配置 store 对象: 在 vm 中配置</li></ul> <h4 id="vuex-多模块编程"><a href="#vuex-多模块编程" class="header-anchor">#</a> vuex 多模块编程</h4> <ul><li>当 vuex 管理的数据个数很多时使用</li> <li>好处: 每个功能模块的数据单独管理, 更方便, 更有扩展性</li></ul> <h4 id="vuex-多模块编程的总-state-结构"><a href="#vuex-多模块编程的总-state-结构" class="header-anchor">#</a> vuex 多模块编程的总 state 结构</h4> <ul><li>要根据具体分出的模块进行调用</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
    user<span class="token operator">:</span> <span class="token punctuation">{</span>
        userInfo<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    home<span class="token operator">:</span> <span class="token punctuation">{</span>
        baseCategoryList<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="vuex-与-api-交互"><a href="#vuex-与-api-交互" class="header-anchor">#</a> vuex 与 api 交互</h4> <ul><li>异步 action: 调用 api 接口请求函数 ==&gt; 成功之后 commit ==&gt; 调用 mutation ==&gt; 更新状态数据</li></ul> <h3 id="利用-lodash-进行函数节流处理"><a href="#利用-lodash-进行函数节流处理" class="header-anchor">#</a> 利用 lodash 进行函数节流处理</h3> <p><strong>问题: mouseenter 事件频繁触发会导致分类列表更新卡的现象</strong></p> <ul><li>解决: 使用 lodash 的 throttle 函数进行节流处理, 限制更新的次数</li></ul> <h4 id="优化减小打包文件-对-lodash-库实现按需引入"><a href="#优化减小打包文件-对-lodash-库实现按需引入" class="header-anchor">#</a> 优化减小打包文件: 对 lodash 库实现按需引入</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">&quot;lodash&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 引入整体lodash  ==&gt; 打包了没用的工具函数, 打包文件变大</span>
<span class="token keyword">import</span> throttle <span class="token keyword">from</span> <span class="token string">&quot;lodash/throttle&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 只引入我需要的工具函数   打包文件减少1.4M</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="解决快速移出后可能显示第一个分类的子分类列表的-bug"><a href="#解决快速移出后可能显示第一个分类的子分类列表的-bug" class="header-anchor">#</a> 解决快速移出后可能显示第一个分类的子分类列表的 bug</h4> <div class="language- extra-class"><pre><code>原因：在最后一个mouseenter事件延迟0.3m才执行更新的回调函数
    在这个0.3s之内可能已经移出去了
解决: 给currentIndex设计了3个值:
        -2: 在整个大div外面
        -1: 进入了包含所有分类的大div上
        &gt;=0: 在某个分类上
    在准备更新currentIndex之前, 需要判断currentIndex当前不能为-2
</code></pre></div><h3 id="优化减少组件对象数量"><a href="#优化减少组件对象数量" class="header-anchor">#</a> 优化减少组件对象数量</h3> <p><strong>使用编程式导航代替声明式导航</strong></p> <div class="language- extra-class"><pre><code>问题: 使用声明式导航跳转Search, 每个分类项都需要渲染一个RouterLink组件对象  ==&gt; 显示缓慢
解决: 使用编程式路由导航, 不用创建多个Routerlink组件对象 ===&gt; 显示更快
</code></pre></div><h3 id="优化事件处理效率"><a href="#优化事件处理效率" class="header-anchor">#</a> 优化事件处理效率</h3> <p><strong>利用事件委托</strong></p> <div class="language- extra-class"><pre><code>问题: 每个分类都绑定了点击监听, 监听回调函数的数量就会非常多  ==&gt; 效率不太高
解决: 使用事件委托, 从n个点击监听变为1个点击监听 ==&gt; 效率高些
问题: 需要在点击回调中得到相应的分类数据?  ===&gt; 利用标签的data自定义属性
</code></pre></div><h3 id="利用标签-data-自定义属性携带动态数据"><a href="#利用标签-data-自定义属性携带动态数据" class="header-anchor">#</a> 利用标签 data 自定义属性携带动态数据</h3> <div class="language- extra-class"><pre><code>在标签中指定自定义属性: &lt;a data-categoryName=&quot;abc&quot; data-category1Id=&quot;3&quot;&gt;
在事件回调函数中读取自定义属性数据: const {categoryname, category1id} = event.target.dataset
</code></pre></div><h3 id="mock-接口数据"><a href="#mock-接口数据" class="header-anchor">#</a> Mock 接口数据</h3> <div class="language- extra-class"><pre><code>下载mockjs
引入mockjs得到Mock
mock接口: Mock.mock('/mock/xxx', {code: 200, data: banners/floors})
mockAjax: 指定baseURL为/mock
api/index.js: reqBanners = () =&gt; mockAjax('/banners')
在组件中调用测试: reqBanners()
</code></pre></div><h3 id="使用-swiper"><a href="#使用-swiper" class="header-anchor">#</a> 使用 swiper</h3> <ul><li>创建并配置 swiper 对象: 必须在列表显示显示之后创建 ===&gt; 在 mounted()中创建</li></ul> <h4 id="解决多个-swiper-效果冲突的问题"><a href="#解决多个-swiper-效果冲突的问题" class="header-anchor">#</a> 解决多个 swiper 效果冲突的问题</h4> <p>​ 问题: 针对某个 swiper 界面创建一个 swiper 对象, 它会影响了其它界面的 swiper 界面</p> <p>​ 原因: new Swiper ('.swiper-container'), 类名选择器匹配了页面中所有的 swiper 界面, 都产生了效果</p> <p>​ 解决: 使用 ref 技术: 通过 ref 标识 swiper 的根 div, new Swiper (this.$refs.swiper)</p> <h4 id="解决-swiper-动态页面轮播的-bug"><a href="#解决-swiper-动态页面轮播的-bug" class="header-anchor">#</a> 解决 swiper 动态页面轮播的 bug</h4> <p>​ 问题: 异步动态获取数据 + 直接在 mounted 中创建 Swiper 对象 ===&gt; 没有轮播效果</p> <p>​ 原因: swiper 对象创建得太早</p> <p>​ 解决: 使 swiper 对象在列表数据显示之后创建</p> <p>​ <strong>办法 1</strong>: 使用延迟定时器延迟一定的时间才创建 ==&gt; 不合适, 因为请求获取的时间是不定的</p> <p>​ <strong>办法 2</strong>: watch + $nextTick()</p> <p>​ 通过 watch 能知道 banners 有数据了(变化了)</p> <p>​ 通过 $nextTick(callback)知道界面也更新了，那我们就可以在 callback 中创建 swiper 对象</p> <p><strong>理解 nextTick()</strong></p> <ul><li><p>nextTick()需要在数据更新之后界面更新前我们调用</p></li> <li><p>指定的回调函数在这次数据更新导致的界面更新完成后立即执行</p></li></ul> <h4 id="解决-floor-组件中轮播有问题的-bug"><a href="#解决-floor-组件中轮播有问题的-bug" class="header-anchor">#</a> 解决 Floor 组件中轮播有问题的 bug</h4> <p>问题: banners 的轮播可以, 但 2 个 Floor 的轮播都没有效果</p> <p>原因: (在 v-for 以后轮播组件已经有数据了，不是从空数组变为有数据，所以 watch 不调用)</p> <p>​ 基础理解: 给组件标签传入的属性值是空数组/undefined, 组件对象会创建，如果是通过 v-for 遍历一个空数组或 undefined 来产生多个标签, 组件对象不会创建</p> <p>​ watch 默认: 初始创建显示不会执行, 只有在数据变化后才会执行</p> <p>解决:</p> <p>​ <strong>办法 1</strong>: mounted() + watch 回调</p> <p>​ mounted()中: 判断如果已经有数据了, 立即创建 swiper 对象</p> <p>​ watch 回调: 判断如果有数据, 延迟创建 swiper 对象</p> <p>​ <strong>办法 2</strong>: watch</p> <p>​ 给 watch 指定 2 个配置</p> <p>​ handler: 判断如果有数据, 延迟创建 swiper 对象</p> <p>​ immediate: 指定为 true, 表示在初始显示之前就会调用一次</p> <h3 id="响应式数据对象"><a href="#响应式数据对象" class="header-anchor">#</a> 响应式数据对象</h3> <h4 id="添加新属性"><a href="#添加新属性" class="header-anchor">#</a> <strong>添加新属性</strong></h4> <p>错误方式:</p> <p>​ 直接添加: this.options.trademark = 'xxx' ==&gt; 不会自动更新界面</p> <p>原因:</p> <p>​ vue 内部没有对添加的属性进行劫持操作(没有对应的 setter 监视)</p> <p>正确方式:</p> <p>​ vm.$set( target, key, value )</p> <p>​ Vue.set( target, key, value )</p> <p>​ 为响应式对象添加一个属性，确保新属性也是响应式的，并且能够触发视图更新</p> <h4 id="删除属性"><a href="#删除属性" class="header-anchor">#</a> 删除属性</h4> <p>错误方式:</p> <p>​ 直接添加: delete this.options.trademark ==&gt; 不会自动更新界面</p> <p>原因:</p> <p>​ vue 内部给响应式属性添加的 setter, 只能监视属性值的改变, 不能监视属性的删除</p> <p>正确方式:</p> <p>​ vm.$delete( target, key )</p> <p>​ Vue.delete( target, key )</p> <p>​ 删除属性, 同时更新界面</p> <h3 id="自定义分页组件-pagination"><a href="#自定义分页组件-pagination" class="header-anchor">#</a> 自定义分页组件: Pagination</h3> <p><strong>自定义通用型/复用型组件的基本步骤</strong></p> <ul><li><p>实现静态组件: 模板/样式写好</p></li> <li><p>设计从外部接收的数据: props</p></li> <li><p>设计内部包含的数据: data</p></li> <li><p>设计基于 props 和 data 的计算属性数据: computed</p></li> <li><p>根据 props 和 data 数据和 computed 进行动态显示</p> <p><strong>v-for 的优先级高于 v-if: 先执行 v-for 的遍历, 每遍历一个再进行 v-if 的判断 面试题</strong></p></li> <li><p>更新数据, 更新界面</p> <p>用户操作组件界面元素时, 更新当前组件的 data 数据</p> <p>子组件更新 data 数据的同时, 可能需要通知父组件做一些更新父组件数据的操作(可能异步/同步)</p> <p>父组件更新 data 数据的同时, 可能也要去更新子组件的数据</p></li></ul> <h2 id="vue-后台项目的重要点"><a href="#vue-后台项目的重要点" class="header-anchor">#</a> Vue 后台项目的重要点</h2> <p>实现 element-ui 的按需打包</p> <p>深度作用选择器修改第三方 UI 组件的内部样式</p> <p>利用深拷贝解决修改不能取消的问题</p> <p>利用 nextTick 与 set 实现: 动态显示输入框并自动获得焦点</p> <p>对 Form 表单前台校验, 减少无用请求</p> <p>Upload 组件管理图片上传: 限制图片大小和文件类型</p> <p>路由权限: 路由全局前置守卫 + 动态添加路由: addRoutes()</p> <p>路由组件懒加载: import()</p> <p>路由跳转的 loading 处理: nprogress</p> <p>登陆成功自动跳转到 redirect 参数路由</p> <h2 id="react-基础"><a href="#react-基础" class="header-anchor">#</a> React 基础</h2> <h3 id="基础-2"><a href="#基础-2" class="header-anchor">#</a> 基础</h3> <ul><li>JSX 语法最终都会经过 babel 编译，编译成 JS 语法</li> <li>组件名首字母必须大写，JSX 一旦标签首字母小写就会当做 html 元素解析，但是 html 中没有这个元素就会报错</li> <li>内部返回虚拟 DOM 对象元素必须有结束符</li> <li>必须要保证更新的数据是一个全新数据（不能 push unshift 等）</li> <li>Fragment 能作为多个虚拟 DOM 元素的根节点 优点：不会生成真实 DOM 元素 简写方式&lt;&gt;&lt;/&gt;</li></ul> <h4 id="通信方式"><a href="#通信方式" class="header-anchor">#</a> 通信方式</h4> <ul><li><p>props</p> <p>用 PropTypes 限制传入类型</p></li> <li><p>refs</p> <p>xxx = React.createRef()，再作用在标签上</p></li> <li><p>消息订阅(subscribe)-发布(publish)机制</p> <p>import PubSub from 'pubsub-js' //引入</p> <p>PubSub.subscribe('delete', function(msg,data){ }); //订阅</p> <p>PubSub.publish('delete', data) //发布消息</p></li> <li><p>context 内部包含两个组件</p> <p>context.Provider 提供者（负责向后代组件提供数据）</p> <p>context.Consumer 消费者（负责消费数据，使用父（爷）组件提供的数据）</p></li> <li><p>forwardRef，获取工厂/纯函数组件的 ref</p> <p>函数组件通过第二个参数接收 ref</p></li> <li><p>render props</p> <p>本质上是一个组件，将 B 组件渲染到 A 组件内部，同时 A 组件传递必要的 props（往往是属性数据，而不是方法）</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>&lt;A render={(count) =&gt; {return &lt;B count={count} /&gt;;}}/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>总结：</p> <p>触发事件元素和要收集数据元素是同一个元素，就 e.target</p> <p>触发事件元素和要收集数据元素不是同一个元素，就用 refs</p></li></ul> <h4 id="生命周期函数"><a href="#生命周期函数" class="header-anchor">#</a> 生命周期函数</h4> <p><strong>始化流程</strong></p> <ul><li>constructor</li> <li>componentWillMount 将要挂载</li> <li>render 开始执行</li> <li>componentDidMount 挂在完成</li></ul> <p><strong>更新流程（三种方式触发）</strong></p> <ol><li><p>父组件 this.setState 导致子组件重新渲染，子组件会触发：</p> <p>componentWillReceiveProps 将要接收数据</p> <p>shouldComponentUpdate</p> <p>componentWillUpdate</p> <p>render</p> <p>componentDidUpdate 更新完成</p></li> <li><p>父组件 this.setState, 父组件触发：</p> <p>shouldComponentUpdate</p> <p>componentWillUpdate</p> <p>render</p> <p>componentDidUpdate</p></li> <li><p>父组件 this.forceUpdate, 父组件触发：</p> <p>componentWillUpdate</p> <p>render</p> <p>componentDidUpdate</p></li></ol> <p><strong>卸载</strong></p> <ul><li><p>componentWillUnmount</p> <p>直接将之前插入到指定容器的 DOM 结构直接移除</p> <p>页面上没有该内容</p></li></ul> <p><strong>即将废弃的生命周期</strong></p> <ul><li>componentWillMount</li> <li>componentWillUpdate</li></ul> <p><strong>新的生命周期</strong></p> <ul><li><p>static getDerivedStateFromProps(props, state){}</p> <p>用来取代 willMount 和 willUpdate</p> <p>render 方法之前调用，并且在初始挂载及后续更新时都会被调用</p> <p>返回一个对象来更新 state，如果返回 null 则不更新任何内容</p></li></ul> <h4 id="重要生命周期函数"><a href="#重要生命周期函数" class="header-anchor">#</a> 重要生命周期函数</h4> <ul><li><p>componentDidMount</p> <p>发送请求、设置定时器、绑定事件等一次性任务</p></li> <li><p>shouldComponentUpdate 做性能优化</p> <p>返回值 true 要更新</p> <p>返回值 false 不更新</p></li> <li><p>componentWillUnmount</p> <p>取消请求、清除定时器、解绑事件等收尾工作</p></li></ul> <h4 id="高阶组件：hoc"><a href="#高阶组件：hoc" class="header-anchor">#</a> 高阶组件：HOC</h4> <ul><li>本质上是一个函数：执行函数接受一个组件作为参数，返回值是一个新组件</li> <li>给高阶组件命名 --&gt; displayName 优先级最高</li> <li>可用高阶函数的形式传参</li> <li>可用装饰器语法调用</li></ul> <h4 id="hooks（钩子）"><a href="#hooks（钩子）" class="header-anchor">#</a> Hooks（钩子）</h4> <ul><li><p>本质就是函数，能让你使用 React 组件的状态和生命周期函数...</p></li> <li><p>作用：让代码更加可复用，不用在定义繁杂的 HOC</p></li> <li><p>使用：</p> <ul><li><p>让工厂函数组件拥有状态数据 state</p> <p><code>const [状态数据（初始化为defaultValue）, 更新状态数据的方法] = React.useState(defaultValue)</code></p></li> <li><p>让工厂函数组件拥有生命周期函数（componentDidMount componentDidUpdate componentWillUnmount）</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>React.useEffect(() =&gt; {
    return () =&gt; {
      PubSub.unsubscribe(&quot;MSG&quot;);
    };
},[])
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul></li></ul> <h4 id="react-router"><a href="#react-router" class="header-anchor">#</a> react-router</h4> <ul><li><p><strong>Hash 模式</strong></p> <p>兼容性好</p> <p>缺点带#</p> <p>刷新页面时只会把#前面地址发请求</p></li> <li><p><strong>History 模式</strong></p> <p>兼容性稍差</p> <p>地址很干净</p> <p>刷新页面时会把所有地址带上发请求（导致开发时刷新浏览器 404 问题）</p> <p>解决方法：</p> <p>​ 出现 404，就直接返回 index.html</p> <p>​ webpack 配置 devServer historyApiFallback: true</p> <p>问题：引入资源（css/js）路径问题</p> <p>​ webpack 配置 output publicPath: &quot;/&quot;</p> <p>​ index.html --&gt; &quot;/bootstrap.css&quot;</p></li> <li><p><strong>API</strong></p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>import {
  BrowserRouter,HashRouter,Link,NavLink,Route,Redirect,Switch,
} from &quot;react-router-dom&quot;;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><strong>路由组件三大属性（都在 props 上）</strong></p> <p>location pathname 当前路由地址 state</p> <p>history push/replace/goBack/goForward/listen 等方法，用来操作浏览历史记录</p> <p>match params 参数</p></li> <li><p><strong>特点</strong></p> <ol><li>默认是模糊匹配，如果想要精准匹配，需要给 Route 标签添加一个属性 exact</li> <li>默认每次匹配都会匹配所有注册路由</li> <li>性能优化相关： Switch, 一旦有匹配成的路由就停止匹配</li></ol></li> <li><p><strong>路由传参</strong></p> <ol><li><p>params 传参</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>&lt;Route path='/home/:id' component={Home}&gt;&lt;/Route&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>props 传参</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>&lt;Route path='/personal' render={() =&gt; &lt;Personal num={123}/&gt;}&gt;&lt;/Route&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></li></ul> <h3 id="面试"><a href="#面试" class="header-anchor">#</a> 面试</h3> <h4 id="工厂函数组件和-es6-类组件的区别"><a href="#工厂函数组件和-es6-类组件的区别" class="header-anchor">#</a> 工厂函数组件和 ES6 类组件的区别</h4> <ol><li><p>this 不一样</p> <p>工厂函数没有 this，ES6 类组件函数中有 this</p></li> <li><p>功能不一样</p> <p>工厂函数没有 this，有些功能默认实现不了；ES6 类组件有 this，所以可以实现</p></li></ol> <ul><li><p>总结</p> <p>工厂函数组件一般用来定义功能简单组件</p> <p>ES6 类组件一般用来定义功能复杂组件</p></li></ul> <h4 id="函数柯里化"><a href="#函数柯里化" class="header-anchor">#</a> 函数柯里化</h4> <ul><li>是闭包的典型应用</li></ul> <div class="language-react line-numbers-mode"><pre class="language-text"><code>// 普通函数
function fn(a, b) { return a + b}
// 经过函数柯里化处理的函数
function fn(a) {
  return function (b) {
    return a + b;
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h4> <ul><li>减少 render 调用次数，从而减少 diff 比较和重新渲染次数</li></ul> <ol><li><p>自己编写 shouldComponentUpdate（nextProps, nextState）函数进行优化</p></li> <li><p>PureComponent：组件内部实现了一种类似 shouldComponentUpdate 的比较</p> <div class="language-react line-numbers-mode"><pre class="language-text"><code>import { PureComponent } from &quot;react&quot;;
export default class Index extends PureComponent {}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol> <ul><li>shouldComponentUpdate 和 PureComponent 同时存在只会生效 shouldComponentUpdate</li></ul> <h4 id="portals"><a href="#portals" class="header-anchor">#</a> Portals</h4> <ul><li>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</li> <li>通常情况下不会使用，一般用于 Modal 组件</li> <li>防止组件卸载/重新创建过程中创建多个 div</li></ul> <h4 id="如何遍历显示子路由"><a href="#如何遍历显示子路由" class="header-anchor">#</a> 如何遍历显示子路由</h4> <ul><li><p>没有通过 Route 加载，所以没有路由组件三大属性</p></li> <li><p>解决：react-router-dom 有一个高阶组件 withRouter，withRouter 内部保存路由组件的三大属性，会给被包装组件传递三大属性</p></li> <li><p>判断 routes 中哪个配置匹配上当前路径</p> <p>forEach 一般写代码推荐 forEach，语义化更好，一般用于要全部遍历的场景</p> <p>for 循环 一般写库或框架，追求极致性能使用。性能好，一般用于遍历可中断的场景</p></li> <li><p>判断 当前路径是否以一级菜单开头：</p> <p>String.prototype.startsWith()</p> <p>正则表达式</p></li></ul> <p>注意：</p> <p>​ 如果 Route 组件不加 exact 属性（严格模式），则会默认匹配以该路径开头的组件</p> <h4 id="虚拟-dom-的-diff-算法"><a href="#虚拟-dom-的-diff-算法" class="header-anchor">#</a> 虚拟 DOM 的 diff 算法</h4> <p><strong>diff 策略</strong></p> <ol><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li> <li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li> <li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ol> <ul><li>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。</li></ul> <p><strong>tree diff</strong></p> <ul><li><p>基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。</p></li> <li><p>即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p></li> <li><p>如果出现了 DOM 节点跨层级的移动操作，性能不好!</p></li></ul> <p><strong>component diff</strong></p> <ul><li>如果是同一类型的组件，按照原策略继续 tree diff。</li></ul> <ul><li><p>如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。</p></li> <li><p>对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。</p></li></ul> <p><strong>element diff</strong></p> <ul><li><p>允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</p></li> <li><p>通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动</p></li> <li><p>在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p></li></ul> <h3 id="深入理解-setstate"><a href="#深入理解-setstate" class="header-anchor">#</a> 深入理解 setState</h3> <ul><li><p><strong>setState()更新状态的两种写法:</strong></p> <p>setState(stateChange,[callback])--------对象式的 setState</p> <p>setState(updater,[callback])---------函数式的 setState</p></li> <li><p><strong>setState()更新状态的动作是同步还是异步的</strong>？（setState()执行的位置对其后续动作的影响）</p> <p>在由 react 所控制的回调函数中更新的动作是【异步】的，如：生命周期钩子 / react 所监听的事件</p> <p>在非 react 控制的异步回调函数中更新的动作是【同步】的，如：定时器的回调 / 原生事件监听回调 /Promise 所指定的成功、失败回调 / ajax 所指定的成功或失败的回调</p></li> <li><p><strong>关于异步的 setState()连续多次调用的问题</strong></p> <ol><li><p>多次调用，如何处理？</p> <p>若是对象式的 setState，多次更新状态的动作合并为一次(只以最后一次为准),所以就调用一次 render</p> <p>若是函数式的 setState，每次更新的动作都会生效(更新的动作不合并)，但是只会调用一次 render</p></li> <li><p>注意：</p> <p>若函数式 setState 和对象式 setState 混用的时候，要把函数式写在最后</p></li> <li><p>如何得到异步更新后的状态？</p> <p>在 setState 第二个参数的回调里</p></li></ol></li></ul> <h2 id="移动端"><a href="#移动端" class="header-anchor">#</a> 移动端</h2> <h3 id="基础知识"><a href="#基础知识" class="header-anchor">#</a> 基础知识</h3> <ul><li><p>1 英寸(inch) = 2.54 厘米(cm)</p></li> <li><p>IPhone 6 的屏幕分辨率为 750 _ 1334 设备独立像素为 375 _ 667</p></li> <li><p>物理像素：由屏幕制造商决定，屏幕生产后无法修改</p></li> <li><p>css 像素：单位是 px，它是为 Web 开发者创造的</p></li> <li><p>设备独立像素的出现，使得即使在【<strong>高清屏</strong>】下，也可以让元素有正常的尺寸，让代码不受到设备的影响，它是设备厂商根据屏幕特性设置的，无法更改。</p></li> <li><p>1 个位图像素对应 1 个物理像素，图片才能得到完美清晰的展示</p></li> <li><p>pc 端视口：默认宽度和浏览器窗口的宽度一致，也被称为初始包含块<code>document.documentElement.clientWidth</code></p></li> <li><p>移动端视口:</p> <ul><li><p>布局视口：一般是**<span style="color:red;">980px</span>**左右，布局视口经过压缩后，横向的宽度用 css 像素表达就不再是 375px 了，而是 980px</p></li> <li><p>视觉视口：用户可见的区域，它的绝对宽度永远和设备屏幕一样宽</p></li> <li><p>理想视口：布局视口宽度 与 屏幕等宽（设备独立像素），靠 meta 标签实现</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width,initial-scale=1.0<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li></ul> <h3 id="适配"><a href="#适配" class="header-anchor">#</a> 适配</h3> <h4 id="_1-viewport-适配"><a href="#_1-viewport-适配" class="header-anchor">#</a> 1.viewport 适配</h4> <ul><li>方法：拿到设计稿之后，设置布局视口宽度为设计稿宽度，然后直接按照设计稿给宽高进行布局即可。</li> <li>一般适用于：计图稿宽度 &lt; 375</li></ul> <h4 id="_2-rem-适配"><a href="#_2-rem-适配" class="header-anchor">#</a> <span style="color:#ee0b41;">2.rem 适配</span></h4> <ul><li>方案一：（百度）
<ol><li>设置完美视口</li> <li><span style="color:#ee0b41;">通过 js 设置根字体大小 = <strong>( 当前设备横向独立像素值 *100) / 设计稿宽度</strong></span></li> <li><span style="color:#ee0b41;">编写样式时，直接以 rem 为单位，值为：<strong>设计值 / 100</strong></span></li> <li>增加 JS 代码进行实时适配</li></ol></li> <li>方法二：（淘宝、搜狐、唯品会）
<ol><li>设置完美视口</li> <li><span style="color:#ee0b41;">通过 js 设置根字体大小 = <strong>当前设备横向独立像素值 / 10</strong></span></li> <li><span style="color:#ee0b41;">编写样式时，直接以 rem 为单位，值为：<strong>设计值 / (设计稿宽度 / 10)</strong></span></li> <li>增加 JS 代码进行实时适配</li></ol></li></ul> <h4 id="_3-vw-适配"><a href="#_3-vw-适配" class="header-anchor">#</a> 3.vw 适配</h4> <p>vw 和 vh 是两个相对单位</p> <ul><li>1vw = 等于布局视口宽度的 1%</li> <li>1vh = 等于布局视口高度的 1%</li></ul> <h4 id="_4-1px-物理像素边框"><a href="#_4-1px-物理像素边框" class="header-anchor">#</a> 4.1px 物理像素边框</h4> <p>高清屏幕下 1px 对应更多的物理像素，所以 1 像素边框看起来比较粗，解决方法如下</p> <h5 id="方法一"><a href="#方法一" class="header-anchor">#</a> 方法一</h5> <p>使用媒查询：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">-webkit-min-device-pixel-ratio</span><span class="token punctuation">:</span> 2<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token selector">#demo</span> <span class="token punctuation">{</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 0.5px solid black<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
或 <span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">-webkit-min-device-pixel-ratio</span><span class="token punctuation">:</span>2<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token selector">#demo2::after</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleY</span><span class="token punctuation">(</span>0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="方法二"><a href="#方法二" class="header-anchor">#</a> 方法二</h5> <p>根据 dpr 扩大布局视口，例如 dpr 为 n 则布局视口改为原来的 n 倍，则元素尺寸均变为原来的 n 分之一，为了保证元素尺寸比例不变，扩大根字体为原来的 n 倍，但整个过程中边框一直用 px 作为单位，不用 rem。</p> <ol><li><p>rem 页面布局</p></li> <li><p>元素的边框设置为 1px</p></li> <li><p>通过 viewport 中的 initial-scale 将布局视口扩大 n 倍，这样页面元素就比原来缩小了 n 倍</p></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> viewport <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;meta[name=viewport]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> scale <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> window<span class="token punctuation">.</span>devicePixelRatio<span class="token punctuation">;</span>
viewport<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&quot;content&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;width=device-width,initial-scale=&quot;</span> <span class="token operator">+</span> scale<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="4"><li>重新设置根元素字体</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> fontSize <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span>
  fontSize <span class="token operator">*</span> window<span class="token punctuation">.</span>devicePixelRatio <span class="token operator">+</span> <span class="token string">&quot;px&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="移动端事件"><a href="#移动端事件" class="header-anchor">#</a> 移动端事件</h3> <ul><li>touchstart 元素上触摸开始时触发</li> <li>touchmove 元素上触摸移动时触发</li> <li>touchend 手指从元素上离开时触发</li> <li>touchcancel 触摸被打断时触发</li></ul> <h3 id="移动端中-touchstart-touchend-click-执行顺序"><a href="#移动端中-touchstart-touchend-click-执行顺序" class="header-anchor">#</a> 移动端中 touchstart,touchend,click 执行顺序</h3> <ul><li>touchstart</li> <li>touchend</li> <li>click，浏览器在 click 后会等待约 300ms 去判断用户是否有双击行为，如果 300ms 内没有再一次 click，那么就判定这是一次单击行为</li></ul> <h3 id="点击穿透"><a href="#点击穿透" class="header-anchor">#</a> 点击穿透</h3> <ul><li><p>touch 事件结束后会默认触发元素的 click 事件</p> <p>方法一：阻止默认行为</p> <p>方法二：使背后元素不具备 click 特性，用 touchXxxx 代替 click</p> <p>方法三：让背后的元素暂时失去 click 事件，300 毫秒左右再复原，属性<code>pointer-events: none;</code></p> <p>方法四：让隐藏的元素延迟 300 毫秒左右再隐藏</p></li></ul> <h3 id="getcomputedstyle"><a href="#getcomputedstyle" class="header-anchor">#</a> getComputedStyle</h3> <ul><li>可读取到非内联样式上的属性</li> <li>可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式</li></ul> <h2 id="小程序"><a href="#小程序" class="header-anchor">#</a> 小程序</h2> <h3 id="_1-小程序特点"><a href="#_1-小程序特点" class="header-anchor">#</a> 1. 小程序特点</h3> <ol><li>体积小，压缩包的体积不能大于 2M</li> <li>没有 DOM 对象</li> <li>基于组件化开发</li> <li>小程序环境不同于浏览器环境
<ol><li>浏览器环境中全局对象： window</li> <li>小程序环境中全局对象：wx</li> <li>小程序环境中没有 window 对象</li></ol></li></ol> <h3 id="_2-小程序适配"><a href="#_2-小程序适配" class="header-anchor">#</a> 2. 小程序适配</h3> <ol><li>小程序适配单位： rpx(responsive px) 响应式单位</li> <li>小程序中规定所有的机型中页面宽度都是 750rpx</li> <li>iphone6: 1 物理像素 = 0.5px = 1rpx ---&gt; 1px = 2rpx</li> <li>小程序底层已经做了 viewport 适配</li></ol> <h3 id="_3-小程序相关语法"><a href="#_3-小程序相关语法" class="header-anchor">#</a> 3. 小程序相关语法</h3> <ol><li><p>数据绑定</p> <ol><li>单项数据流: Model ---&gt; view</li> <li>修改状态数据： this.setData() 同步行为</li> <li>页面中的数据均来自于 data 中，使用 data 中的数据的时候记住使用表达式{{}}</li></ol></li> <li><p>事件绑定</p> <ol><li>事件分类： 冒泡事件 || 非冒泡事件</li> <li>绑定的方式： bind + 事件名 || catch + 事件名</li></ol></li> <li><p>路由跳转</p> <ol><li>wx.navigateTo() || wx.redirectTo()</li></ol></li> <li><p>本地存储</p> <ol><li>语法：
<ol><li>wx.setStorage() || wx.setStorageSync()</li> <li>wx.getStorage() || wx.getStorageSync()</li></ol></li> <li>注意点
<ol><li>单个 key 上限是 1M</li> <li>整体上限是 10M</li></ol></li></ol></li> <li><p>全局传参</p> <p>app.js 中可定义全局参数 globalData</p></li></ol> <h3 id="_4-向事件对象传参"><a href="#_4-向事件对象传参" class="header-anchor">#</a> 4. 向事件对象传参</h3> <ol><li>语法
<ol><li>id=value</li> <li>data-key=value</li></ol></li> <li>获取
<ol><li>id: event.target.id || event.currentTarget.id</li> <li>data-key: event.target.dataset.key || event.currentTarget.dataset.key</li></ol></li> <li>使用场景
<ol><li>id：通常需要向 event 对象传递单一且唯一的标识</li> <li>data-key: 需要向 event 对象传递多个标识数据</li></ol></li></ol> <h3 id="小程序获取用户唯一标识（openid）"><a href="#小程序获取用户唯一标识（openid）" class="header-anchor">#</a> 小程序获取用户唯一标识（openId）</h3> <ol><li>客户端先通过 wx.login(获取 code</li> <li>wx.request()发送 code 给服务器</li> <li>服务器端发送请求携带参数(code, appSecret（开发密钥）, appId)给微信服务器获取 openId</li> <li>微信返回 openId 给服务器后，服务器进行加密再返回给前端</li> <li>前端进行本地储存，下次发送请求时携带参数</li></ol> <h3 id="小程序支付流程"><a href="#小程序支付流程" class="header-anchor">#</a> 小程序支付流程</h3> <ol><li>用户在小程序客服端下单(包含用户及商品信息)</li> <li>小程序客户端发送下单支付请求给商家服务器</li> <li>商家服务器同微信服务器对接获取唯一标识 openID</li> <li>商家服务器根据 openId 生成商户订单(包含商户信息)</li> <li>商家服务器发送请求调用统一下单 API 获取预支付订单信息</li> <li>商家对预支付信息签名加密后返回给小程序客户端</li> <li>用户确认支付（鉴权调起支付）</li> <li>微信服务器返回支付结果给小程序客户端</li> <li>微信服务器推送支付结果给商家服务器端</li></ol> <h3 id="面试问题"><a href="#面试问题" class="header-anchor">#</a> 面试问题</h3> <ul><li><p>Iphone6 的 dpr 为多少？Iphone6Plus 比 Iphone6 显示图像清晰吗？</p> <p>视网膜屏幕是分辨率超过人眼识别极限的高分辨率屏幕，Iphone4 的 dpr = 2; 人类肉眼分辨的极限</p></li> <li><p>生命周期函数实际测试和官网描述有差</p></li> <li><p>wx.setStorage()，单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB</p></li> <li><p>性能优化</p> <p>一个页面一次只有一个 video 标签，其余的使用 image 代替</p></li> <li><p>请求相关</p> <p>小程序为了安全起见只支持 Https 请求</p> <p>wx.request 最大并发限制 10 个</p></li> <li><p>如何使用组件</p> <p>先创建组件，在对应的 json 文件下设置 component: true</p> <p>到使用组件页面的 json 文件中，注册组件填写相应的路径</p></li> <li><p>使用 npm 包</p> <p>下载后，勾选使用 npm 模块，再构建 npm，会将 node_modules 中的包打包到 miniprogram_npm 中</p></li> <li><p>分包相关</p> <p>分包后可解决 2M 限制，并且能分包加载内容，提高性能</p> <p>分包后单个包的体积不能大于 2M，所有包的体积不能大于 16M</p> <ol><li><p>常规分包</p> <p>加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容</p> <p>分包的页面可以访问主包的文件，数据，图片等资源</p></li> <li><p>独立分包</p> <p>独立分包可单独访问分包的内容，不需要下载主包</p> <p>独立分包不能依赖主包或者其他包的内容</p> <p>通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页 || 活动页</p></li> <li><p>分包预下载</p> <p>在加载当前包的时候可以设置预下载其他的包</p> <p>缩短用户等待时间，提高用户体验</p></li></ol></li></ul> <h3 id="开发相关"><a href="#开发相关" class="header-anchor">#</a> 开发相关</h3> <ul><li>setData 行为始终是同步的</li> <li>H5 中实现滑块功能，推荐大家使用：better-scroll</li></ul> <h4 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h4> <ul><li><p>封装函数：</p> <ol><li><p>功能点明确</p></li> <li><p>函数内部保留静态的数据</p></li> <li><p>将动态的数据抽取出来作为形参，由使用者根据场景不同动态传入实参</p></li></ol></li> <li><p>封装组件：</p> <ol><li><p>功能点明确 || 呈现效果</p></li> <li><p>UI 组件 || js 组件</p></li> <li><p>组件内部保留静态的数据</p></li> <li><p>将动态的数据抽取出来作为 props 属性，由使用者根据场景不同动态以标签属性的形式导入</p></li> <li><p>封装良好的组件应该规定传入 props 数据的必要性还有数据类型 propsType</p></li></ol></li></ul> <h2 id="express"><a href="#express" class="header-anchor">#</a> express</h2> <h3 id="_1-基本使用"><a href="#_1-基本使用" class="header-anchor">#</a> 1. 基本使用</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 引入</span>
<span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;express&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1. 生成应用实例</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// app: application 代表整个应用</span>

<span class="token comment">// 3. 注册路由</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> respone</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;1111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回数据</span>
  respone<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&quot;success data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;2222&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&quot;login data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">&quot;/register&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;4444&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&quot;register data&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 绑定监听(设置当前项目的端口号)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">&quot;3001&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;服务器启动失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;服务器启动成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;服务器地址： http://localhost:3001&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="_2-路由"><a href="#_2-路由" class="header-anchor">#</a> 2. 路由</h3> <ol><li>路由分类
<ol><li>前端路由</li> <li>后端路由</li></ol></li> <li>前端路由
<ol><li>发请求不需要走网络传输层</li> <li>需要由前端指定的 js 库解析(vue-router, react-router-dom)</li> <li>应用： SPA（single page application）</li></ol></li> <li>后端路由
<ol><li>发请求需要走网络传输层</li> <li>需要由服务器端解析</li> <li>应用： 前后端交互</li></ol></li></ol> <h3 id="_3-路由参数"><a href="#_3-路由参数" class="header-anchor">#</a> 3. 路由参数</h3> <ol><li>get 请求
<ol><li>params 参数：
<ol><li>请求： url/:id ==&gt; url/参数</li> <li>获取： req.params</li></ol></li> <li>query 参数:
<ol><li>请求：url?key=value&amp;key2=value2</li> <li>获取: req.query</li></ol></li> <li>总结:
<ol><li>params 参数只能有一个参数，适用于参数为标识数据</li> <li>query 参数可以有多个</li></ol></li></ol></li> <li>post 请求
<ol><li>params 参数</li> <li>query 参数</li> <li>body 参数
<ol><li>相对安全</li> <li>获取 req.body，但是不能直接获取，需要使用中间键</li></ol></li></ol></li></ol> <h3 id="_4-res-常用方法"><a href="#_4-res-常用方法" class="header-anchor">#</a> 4. res 常用方法</h3> <ol><li>res.end() 返回响应: 直接返回数据</li> <li>res.send() 根据数据类型不同，自动做出判断处理，再返回，如：中文的话会自动设置 content-type</li> <li>res.set() 设置响应头的方法</li> <li>res.json() 返回的数据一定是 json 数据，直接返回</li> <li>res.cookie() 设置 cookie</li> <li>res.status() 设置状态码</li> <li>res.redirect() 返回的是新地址，状态码通常是 302，浏览器接收到响应以后会跳转至新的地址</li> <li>res.download() 返回的文件信息，浏览器会自动下载该文件</li></ol> <h3 id="_5-中间件"><a href="#_5-中间件" class="header-anchor">#</a> 5. 中间件</h3> <ol><li>本质
<ol><li>就是一个函数</li></ol></li> <li>作用
<ol><li>处理请求，返回响应数据</li> <li>获取，修改请求的参数及响应数据</li> <li>执行下一个中间键</li></ol></li> <li>体现形式
<ol><li>(req, res, next) =&gt; {}</li> <li>req: 请求对象</li> <li>res: 响应对象</li> <li>next：是一个方法，用来调用下一个中间键</li></ol></li> <li>注意
<ol><li>连续使用多个中间键的时候返回数据的动作应该放在最后且只有一次</li> <li>路由对应的回调 也是中间键函数</li> <li>如果请求方法和中间键共存的情况下，只能匹配一个，谁在前就匹配谁（满足匹配条件情况下）</li></ol></li></ol></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/dakang824/edit/master/docs/04.更多/03.面试/02.前端常见技术面试.md" target="_blank" rel="noopener noreferrer">编辑</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/01/10, 04:35:43</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/aea6571b7a8bae86/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">面试套路集锦</div></a> <a href="/pages/2d615df9a36a98ed/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">一个完美主义者的自我救赎</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/aea6571b7a8bae86/" class="prev">面试套路集锦</a></span> <span class="next"><a href="/pages/2d615df9a36a98ed/">一个完美主义者的自我救赎</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/4cbc21/"><div>Git命令思维导图</div></a> <span>11-18</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/49ee30/"><div>Git分支开发工作流</div></a> <span>11-18</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/8292d8/"><div>常用Git命令清单</div></a> <span>11-18</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1172248038@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/dakang824" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=104200041" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2021
    <span>Evan Xu | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.da88fcfe.js" defer></script><script src="/assets/js/2.d6d313e5.js" defer></script><script src="/assets/js/71.5951b3f0.js" defer></script>
  </body>
</html>